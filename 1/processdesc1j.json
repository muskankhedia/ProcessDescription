[{"Process":{"Description":"jackd is the JACK audio server daemon, a low-latency audio server. Originally written for the GNU\/Linux operating system, it also supports Mac OS X and various Unix platforms. JACK can connect a number of different client applications to an audio device and also to each other. Most clients are external, running in their own processes as normal applications. JACK also supports internal clients, which run within the jackd process using a loadable \"plugin\" interface. JACK differs from other audio servers in being designed from the ground up for professional audio work. It focuses on two key areas: synchronous execution of all clients, and low latency operation. For the latest JACK information, please consult the web site, <http:\/\/www.jackaudio.org>.","Process Name":"jackd","Link":"https:\/\/linux.die.net\/man\/1\/jackd"}},{"Process":{"Description":"jackd is the JACK audio server daemon, a low-latency audio server. Originally written for the GNU\/Linux operating system, it also supports Mac OS X and various Unix platforms. JACK can connect a number of different client applications to an audio device and also to each other. Most clients are external, running in their own processes as normal applications. JACK also supports internal clients, which run within the jackd process using a loadable \"plugin\" interface. JACK differs from other audio servers in being designed from the ground up for professional audio work. It focuses on two key areas: synchronous execution of all clients, and low latency operation. For the latest JACK information, please consult the web site, <http:\/\/www.jackaudio.org>.","Process Name":"jackstart","Link":"https:\/\/linux.die.net\/man\/1\/jackstart"}},{"Process":{"Description":"openjade is an implementation of the ISO\/IEC 10179:1996 standard DSSSL language. The DSSSL engine receives as input an SGML or XML document and transforms it into formats like: * XML representation of the flow object tree. * RTF format that can be rendered and printed with Microsoft's free Word Viewer 97 * TeX format * MIF format that can be rendered and printed with Framemaker * SGML or XML format. This is used in conjunction with non-standard flow object classes to generate SGML, thus allowing openjade to be used for SGML\/XML transformations. The system identifier of the document to be processed is specified as an argument to openjade. If this is omitted, standard input will be read. openjade determines the system identifier for the DSSSL specification as follows: 1. If the -d option is specified, it will use the argument as the system identifier. 2. Otherwise, it will look for processing instructions in the prolog of the document. Two kinds of processing instruction are recognized: <?stylesheet href=\"sysid\" type=\"text\/dsssl\"> The system data of the processing instruction is parsed like an SGML start-tag. It will be parsed using the reference concrete syntax whatever the actual concrete syntax of the document. The name that starts the processing instruction can be either stylesheet, xml-stylesheet or xml:stylesheet. The processing instruction will be ignored unless the value of the type attribute is one of text\/dsssl, text\/x-dsssl, application\/dsssl, or application\/x-dsssl. The value of href attribute is the system identifier of the DSSSL specification. <?dsssl sysid> The system identifier is the portion of the system data of the processing instruction following the initial name and any whitespace. Although the processing instruction is only recognized in the prolog, it need not occur in the document entity. For example, it could occur in a DTD. The system identifier will be interpreted relative to where the the processing instruction occurs. 3. Otherwise, it will use the system identifier of the document with any extension changed to .dsl. A DSSSL specification document can contain more than one style-specification. If the system identifier of the DSSSL specification is followed by #id, then openjade will use the style-specification whose unique identifier is id. This is allowed both with the -d option and with the processing instructions. The DSSSL specification must be an SGML document conforming to the DSSSL architecture. For an example, see dsssl\/demo.dsl. openjade supports the following options in addition to the normal OpenSP (see onsgmls(1)) options (note that all options are case-sensitive, ie -g and -G are different options): -d dsssl_spec This specifies that dsssl_spec is the system identifier of the DSSSL specification to be used. -G Debug mode. When an error occurs in the evaluation of an expression, openjade will display a stack trace. Note that this disables tail-call optimization. -c filename The filename arguments specify catalog files rather than the document entity. The document entity is specified by the first DOCUMENT entry in the catalog files. -s Strict compliance mode. Currently the only effect is that jade doesn't use any predefined character names, sdata-entity mappings or name-characters. This is useful for checking that your stylesheet is portable to other DSSSL implementations and that it is strictly compliant to the DSSSL specifications. -t output_type output_type specifies the type of output as follows: fot An XML representation of the flow object tree rtf rtf-95 RTF (used for SGML\/XML to RTF transformations) Microsoft's Rich Text Format. rtf-95 produces output optimized for Word 95 rather than Word 97. tex TeX (used for SGML\/XML to TeX transformations) sgml sgml-raw SGML (used for SGML\/XML to SGML transformations). sgml-raw doesn't emit linebreaks in tags. xml xml-raw XML (used for SGML\/XML to XML transformations). xml-raw doesn't emit linebreaks in tags. html HTML (used for SGML\/XML to HTML transformations) mif MIF (used for SGML\/XML to MIF transformations) -o output_file Write output to output_file instead of the default. The default filename is the name of the last input file with its extension replaced by the name of the type of output. If there is no input filename, then the extension is added onto jade-out. -V variable This is equivalent to doing (define variable #t) except that this definition will take priority over any definition of variable in a style-sheet. -V variable=value This is equivalent to doing (define variable \" value\") except that this definition will take priority over any definition of variable in a style-sheet. -V (define variable value) This is equivalent to doing (define variable value) except that this definition will take priority over any definition of variable in a style-sheet. Note that you will probably have to use some escaping mechanism for the spaces to get the entire scheme expression parsed as one cmdline argument. -w type Control warnings and errors. Multiple -w options are allowed. The following values of type enable warnings: xml Warn about constructs that are not allowed by XML. mixed Warn about mixed content models that do not allow #pcdata anywhere. sgmldecl Warn about various dubious constructions in the SGML declaration. should Warn about various recommendations made in ISO 8879 that the document does not comply with. (Recommendations are expressed with ''should'', as distinct from requirements which are usually expressed with ''shall''.) default Warn about defaulted references. duplicate Warn about duplicate entity declarations. undefined Warn about undefined elements: elements used in the DTD but not defined. unclosed Warn about unclosed start and end-tags. empty Warn about empty start and end-tags. net Warn about net-enabling start-tags and null end-tags. min-tag Warn about minimized start and end-tags. Equivalent to combination of unclosed, empty and net warnings. unused-map Warn about unused short reference maps: maps that are declared with a short reference mapping declaration but never used in a short reference use declaration in the DTD. unused-param Warn about parameter entities that are defined but not used in a DTD. Unused internal parameter entities whose text is INCLUDE or IGNORE won't get the warning. notation-sysid Warn about notations for which no system identifier could be generated. all Warn about conditions that should usually be avoided (in the opinion of the author). Equivalent to: mixed, should, default, undefined, sgmldecl, unused-map, unused-param, empty and unclosed. A warning can be disabled by using its name prefixed with no-. Thus -wall -wno-duplicate will enable all warnings except those about duplicate entity declarations. The following values for warning_type disable errors: no-idref Do not give an error for an ID reference value which no element has as its ID. The effect will be as if each attribute declared as an ID reference value had been declared as a name. no-significant Do not give an error when a character that is not a significant character in the reference concrete syntax occurs in a literal in the SGML declaration. This may be useful in conjunction with certain buggy test suites. no-valid Do not require the document to be type-valid. This has the effect of changing the SGML declaration to specify VALIDITY NOASSERT and IMPLYDEF ATTLIST YES ELEMENT YES. An option of -wvalid has the effect of changing the SGML declaration to specify VALIDITY TYPE and IMPLYDEF ATTLIST NO ELEMENT NO. If neither -wvalid nor -wno-valid are specified, then the VALIDITY and IMPLYDEF specified in the SGML declaration will be used.","Process Name":"jade","Link":"https:\/\/linux.die.net\/man\/1\/jade"}},{"Process":{"Description":"This manual page was derived from the manual page for LaTeX and is not meant to be exhaustive. The complete documentation for this version of TeX can be found in the info file or manual Web2C: A TeX implementation. JadeTeX is a TeX macro package, not a modification to the TeX source program, so all the capabilities described in tex(1) are present. pdfjadetex is the PDFTeX version of the jadeTeX format.","Process Name":"jadetex","Link":"https:\/\/linux.die.net\/man\/1\/jadetex"}},{"Process":{"Description":"The jar tool combines multiple files into a single JAR archive file. jar is a general-purpose archiving and compression tool, based on ZIP and the ZLIB @ http:\/\/www.gzip.org\/zlib\/ compression format. However, jar was designed mainly package java applets or applications into a single archive. When the components of an applet or application (files, images and sounds) are combined into a single archive, they can be downloaded by a java agent (like a browser) in a single HTTP transaction, rather than requiring a new connection for each piece. This dramatically improves download times. jar also compresses files and so further improves download time. In addition, it allows individual entries in a file to be signed by the applet author so that their origin can be authenticated. The syntax for the jar tool is almost identical to the syntax for the tar command. A jar archive can be used as a class path @ http:\/\/ccc.sfbay\/4291383\/attachment\/classpath.html entry, whether or not it is compressed. Typical usage to combine files into a jar file is: % jar cf myFile.jar *.class\n\n In this example, all the class files in the current directory are placed into the file named myFile.jar. The jar tool automatically generates a manifest file entry named META-INF\/MANIFEST.MF. It is always the first entry in the jar file. The manifest file declares meta-information about the archive, and stores that data as name : value pairs. Refer to the JAR file specification @ http:\/\/ccc.sfbay\/guide\/jar\/jar.html#JAR%20Manifest for details explaining how the jar tool stores meta-information in the manifest file. If a jar file should include name : value pairs contained in an existing manifest file, specify that file using the -m option: % jar cmf myManifestFile myFile.jar *.class\n\n An existing manifest file must end with a new line character. jar does not parse the last line of a manifest file if it does not end with a new line character. Note: A jar command that specifies cfm on the command line instead of cmf (the order of the m and -f options are reversed), the jar command line must specify the name of the jar archive first, followed by the name of the manifest file: % jar cfm myFile.jar myManifestFile *.class\n\n The manifest is in a text format inspired by RFC822 ASCII format, so it is easy to view and process manifest-file contents. To extract the files from a jar file, use x: % jar xf myFile.jar\n\n To extract individual files from a jar file, supply their filenames: % jar xf myFile.jar foo bar\n\n Beginning with version 1.3 of the Java 2 SDK, the jar utility supports JarIndex @ http:\/\/ccc.sfbay\/guide\/jar\/jar.html#JAR%20Index, which allows application class loaders to load classes more efficiently from jar files. If an application or applet is bundled into multiple jar files, only the necessary jar files will be downloaded and opened to load classes. This performance optimization is enabled by running jar with the -ioption. It will generate package location information for the specified main jar file and all the jar files it depends on, which need to be specified in the Class-Path attribute of the main jar file's manifest. % jar i main.jar\n\n In this example, an INDEX.LIST file is inserted into the META-INF directory of main.jar. The application class loader uses the information stored in this file for efficient class loading. For details about how location information is stored in the index file, refer to the JarIndex specification. To copy directories, first compress files in dir1 to stdout, then extract from stdin to dir2 (omitting the -f option from both jar commands): % (cd dir1; jar c .) | (cd dir2; jar x)\n\n To review command samples which use jar to opeate on jar files and jar file manifests, see Examples, below. Also refer to the jar trail of the Java Tutorial @ http:\/\/java.sun.com\/docs\/books\/tutorial\/jar.","Process Name":"jar-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jar-java-1.6.0-openjdk"}},{"Process":{"Description":"The jar tool combines multiple files into a single JAR archive file. jar is a general-purpose archiving and compression tool, based on ZIP and the ZLIB @ http:\/\/www.gzip.org\/zlib\/ compression format. However, jar was designed mainly package java applets or applications into a single archive. When the components of an applet or application (files, images and sounds) are combined into a single archive, they can be downloaded by a java agent (like a browser) in a single HTTP transaction, rather than requiring a new connection for each piece. This dramatically improves download times. jar also compresses files and so further improves download time. In addition, it allows individual entries in a file to be signed by the applet author so that their origin can be authenticated. The syntax for the jar tool is almost identical to the syntax for the tar command. A jar archive can be used as a class path entry, whether or not it is compressed. Typical usage to combine files into a jar file is: % jar cf myFile.jar *.class\n\n In this example, all the class files in the current directory are placed into the file named myFile.jar. The jar tool automatically generates a manifest file entry named META-INF\/MANIFEST.MF. It is always the first entry in the jar file. The manifest file declares meta-information about the archive, and stores that data as name : value pairs. Refer to the JAR file specification @ http:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/jar\/jar.html#JAR%20Manifest for details explaining how the jar tool stores meta-information in the manifest file. If a jar file should include name : value pairs contained in an existing manifest file, specify that file using the -m option: % jar cmf myManifestFile myFile.jar *.class\n\n An existing manifest file must end with a new line character. jar does not parse the last line of a manifest file if it does not end with a new line character. Note: A jar command that specifies cfm on the command line instead of cmf (the order of the m and -f options are reversed), the jar command line must specify the name of the jar archive first, followed by the name of the manifest file: % jar cfm myFile.jar myManifestFile *.class\n\n The manifest is in a text format inspired by RFC822 ASCII format, so it is easy to view and process manifest-file contents. To extract the files from a jar file, use x: % jar xf myFile.jar\n\n To extract individual files from a jar file, supply their filenames: % jar xf myFile.jar foo bar\n\n Beginning with version 1.3 of the JDK, the jar utility supports JarIndex @ http:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/jar\/jar.html#JAR_Index, which allows application class loaders to load classes more efficiently from jar files. If an application or applet is bundled into multiple jar files, only the necessary jar files will be downloaded and opened to load classes. This performance optimization is enabled by running jar with the -ioption. It will generate package location information for the specified main jar file and all the jar files it depends on, which need to be specified in the Class-Path attribute of the main jar file's manifest. % jar i main.jar\n\n In this example, an INDEX.LIST file is inserted into the META-INF directory of main.jar. The application class loader uses the information stored in this file for efficient class loading. For details about how location information is stored in the index file, refer to the JarIndex specification. To copy directories, first compress files in dir1 to stdout, then extract from stdin to dir2 (omitting the -f option from both jar commands): % (cd dir1; jar c .) | (cd dir2; jar x)\n\n To review command samples which use jar to opeate on jar files and jar file manifests, see Examples, below. Also refer to the jar trail of the Java Tutorial @ http:\/\/docs.oracle.com\/javase\/tutorial\/deployment\/jar.","Process Name":"jar-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jar-java-1.7.0-openjdk"}},{"Process":{"Description":"The jarsigner tool is used for two purposes: 1. to sign Java ARchive (JAR) files, and 2. to verify the signatures and integrity of signed JAR files. The JAR feature enables the packaging of class files, images, sounds, and other digital data in a single file for faster and easier distribution. A tool named jar enables developers to produce JAR files. (Technically, any zip file can also be considered a JAR file, although when created by jar or processed by jarsigner, JAR files also contain a META-INF\/MANIFEST.MF file.) A digital signature is a string of bits that is computed from some data (the data being \"signed\") and the private key of an entity (a person, company, etc.). Like a handwritten signature, a digital signature has many useful characteristics: o Its authenticity can be verified, via a computation that uses the public key corresponding to the private key used to generate the signature. o It cannot be forged, assuming the private key is kept secret. o It is a function of the data signed and thus can't be claimed to be the signature for other data as well. o The signed data cannot be changed; if it is, the signature will no longer verify as being authentic. In order for an entity's signature to be generated for a file, the entity must first have a public\/private key pair associated with it, and also one or more certificates authenticating its public key. A certificate is a digitally signed statement from one entity, saying that the public key of some other entity has a particular value. jarsigner uses key and certificate information from a keystore to generate digital signatures for JAR files. A keystore is a database of private keys and their associated X.509 certificate chains authenticating the corresponding public keys. The keytool utility is used to create and administer keystores. jarsigner uses an entity's private key to generate a signature. The signed JAR file contains, among other things, a copy of the certificate from the keystore for the public key corresponding to the private key used to sign the file. jarsigner can verify the digital signature of the signed JAR file using the certificate inside it (in its signature block file). Starting in J2SE 5.0, jarsigner can generate signatures that include a timestamp, thus enabling systems\/deployer (including Java Plug-in) to check whether the JAR file was signed while the signing certificate was still valid. In addition, APIs were added in J2SE 5.0 to allow applications to obtain the timestamp information. At this time, jarsigner can only sign JAR files created by the SDK jar tool or zip files. (JAR files are the same as zip files, except they also have a META-INF\/MANIFEST.MF file. Such a file will automatically be created when jarsigner signs a zip file.) The default jarsigner behavior is to sign a JAR (or zip) file. Use the -verify option to instead have it verify a signed JAR file. Compatibility with JDK 1.1 The keytool and jarsigner tools completely replace the javakey tool provided in JDK 1.1. These new tools provide more features than javakey, including the ability to protect the keystore and private keys with passwords, and the ability to verify signatures in addition to generating them. The new keystore architecture replaces the identity database that javakey created and managed. There is no backwards compatibility between the keystore format and the database format used by javakey in 1.1. However, o It is possible to import the information from an identity database into a keystore, via the keytool -identitydb command. o jarsigner can sign JAR files also previously signed using javakey. o jarsigner can verify JAR files signed using javakey. Thus, it recognizes and can work with signer aliases that are from a JDK 1.1 identity database rather than a Java 2 SDK keystore. The following table explains how JAR files that were signed in JDK 1.1.x are treated in the Java 2 platform. Notes: 1. If an identity\/alias is mentioned in the policy file, it must be imported into the keystore for the policy file to have any effect on privileges granted. 2. The policy file\/keystore combination has precedence over a trusted identity in the identity database. 3. Untrusted identities are ignored in the Java 2 platform. 4. Only trusted identities can be imported into Java 2 SDK keystores. Keystore Aliases All keystore entities are accessed via unique aliases. When using jarsigner to sign a JAR file, you must specify the alias for the keystore entry containing the private key needed to generate the signature. For example, the following will sign the JAR file named \"MyJARFile.jar\", using the private key associated with the alias \"duke\" in the keystore named \"mystore\" in the \"working\" directory. Since no output file is specified, it overwrites MyJARFile.jar with the signed JAR file.     jarsigner -keystore \/working\/mystore -storepass myspass\n      -keypass dukekeypasswd MyJARFile.jar duke\n\n Keystores are protected with a password, so the store password (in this case \"myspass\") must be specified. You will be prompted for it if you don't specify it on the command line. Similarly, private keys are protected in a keystore with a password, so the private key's password (in this case \"dukekeypasswd\") must be specified, and you will be prompted for it if you don't specify it on the command line and it isn't the same as the store password. Keystore Location jarsigner has a -keystore option for specifying the URL of the keystore to be used. The keystore is by default stored in a file named .keystore in the user's home directory, as determined by the user.home system property. On Solaris systems user.home defaults to the user's home directory. Note that the input stream from the -keystore option is passed to the KeyStore.load method. If NONE is specified as the URL, then a null stream is passed to the KeyStore.load method. NONE should be specified if the KeyStore is not file-based, for example, if it resides on a hardware token device. Keystore Implementation The KeyStore class provided in the java.security package supplies well-defined interfaces to access and modify the information in a keystore. It is possible for there to be multiple different concrete implementations, where each implementation is that for a particular type of keystore. Currently, there are two command-line tools that make use of keystore implementations (keytool and jarsigner), and also a GUI-based tool named Policy Tool. Since KeyStore is publicly available, Java 2 SDK users can write additional security applications that use it. There is a built-in default implementation, provided by Sun Microsystems. It implements the keystore as a file, utilizing a proprietary keystore type (format) named \"JKS\". It protects each private key with its individual password, and also protects the integrity of the entire keystore with a (possibly different) password. Keystore implementations are provider-based. More specifically, the application interfaces supplied by KeyStore are implemented in terms of a \"Service Provider Interface\" (SPI). That is, there is a corresponding abstract KeystoreSpi class, also in the java.security package, which defines the Service Provider Interface methods that \"providers\" must implement. (The term \"provider\" refers to a package or a set of packages that supply a concrete implementation of a subset of services that can be accessed by the Java Security API.) Thus, to provide a keystore implementation, clients must implement a provider and supply a KeystoreSpi subclass implementation, as described in How to Implement a Provider for the Java Cryptography Architecture @ http:\/\/java.sun.com\/javase\/6\/docs\/technotes\/guides\/security\/HowToImplAProvider.html. Applications can choose different types of keystore implementations from different providers, using the \"getInstance\" factory method supplied in the KeyStore class. A keystore type defines the storage and data format of the keystore information, and the algorithms used to protect private keys in the keystore and the integrity of the keystore itself. Keystore implementations of different types are not compatible. keytool works on any file-based keystore implementation. (It treats the keytore location that is passed to it at the command line as a filename and converts it to a FileInputStream, from which it loads the keystore information.) The jarsigner and policytool tools, on the other hand, can read a keystore from any location that can be specified using a URL. For jarsigner and keytool, you can specify a keystore type at the command line, via the -storetype option. For Policy Tool, you can specify a keystore type via the \"Change Keystore\" command in the Edit menu. If you don't explicitly specify a keystore type, the tools choose a keystore implementation based simply on the value of the keystore.type property specified in the security properties file. The security properties file is called java.security, and it resides in the SDK security properties directory, java.home\/lib\/security, where java.home is the runtime environment's directory (the jre directory in the SDK or the top-level directory of the Java 2 Runtime Environment). Each tool gets the keystore.type value and then examines all the currently-installed providers until it finds one that implements keystores of that type. It then uses the keystore implementation from that provider. The KeyStore class defines a static method named getDefaultType that lets applications and applets retrieve the value of the keystore.type property. The following line of code creates an instance of the default keystore type (as specified in the keystore.type property):     KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n\n The default keystore type is \"jks\" (the proprietary type of the keystore implementation provided by Sun). This is specified by the following line in the security properties file:     keystore.type=jks\n\n Note: Case doesn't matter in keystore type designations. For example, \"JKS\" would be considered the same as \"jks\". To have the tools utilize a keystore implementation other than the default, change that line to specify a different keystore type. For example, if you have a provider package that supplies a keystore implementation for a keystore type called \"pkcs12\", change the line to     keystore.type=pkcs12\n\n Note that if you us the PKCS#11 provider package, you should refer to the KeyTool and JarSigner @ http:\/\/java.sun.com\/javase\/6\/docs\/technotes\/guides\/security\/p11guide.html#keytooljarsigner section of the Java PKCS#11 Reference Guide for details. Supported Algorithms By default, jarsigner signs a JAR file using either o DSA (Digital Signature Algorithm) with the SHA-1 digest algorithm, or o the RSA algorithm with the MD5 digest algorithm. That is, if the signer's public and private keys are DSA keys, jarsigner will sign the JAR file using the \"SHA1withDSA\" algorithm. If the signer's keys are RSA keys, jarsigner will attempt to sign the JAR file using the \"MD5withRSA\" algorithm. These default signature algorithms can be overridden using the -sigalg option. The Signed JAR File When jarsigner is used to sign a JAR file, the output signed JAR file is exactly the same as the input JAR file, except that it has two additional files placed in the META-INF directory: o a signature file, with a .SF extension, and o a signature block file, with a .DSA extension. The base file names for these two files come from the value of the -sigFile option. For example, if the option appears as   -sigFile MKSIGN\n\n the files are named \"MKSIGN.SF\" and \"MKSIGN.DSA\". If no -sigfile option appears on the command line, the base file name for the .SF and .DSA files will be the first 8 characters of the alias name specified on the command line, all converted to upper case. If the alias name has fewer than 8 characters, the full alias name is used. If the alias name contains any characters that are not allowed in a signature file name, each such character is converted to an underscore (\"_\") character in forming the file name. Legal characters include letters, digits, underscores, and hyphens. The Signature (.SF) File A signature file (the .SF file) looks similar to the manifest file that is always included in a JAR file when jarsigner is used to sign the file. That is, for each source file included in the JAR file, the .SF file has three lines, just as in the manifest file, listing the following: o the file name, o the name of the digest algorithm used (SHA), and o a SHA digest value. In the manifest file, the SHA digest value for each source file is the digest (hash) of the binary data in the source file. In the .SF file, on the other hand, the digest value for a given source file is the hash of the three lines in the manifest file for the source file. The signature file also, by default, includes a header containing a hash of the whole manifest file. The presence of the header enables verification optimization, as described in JAR File Verification. The Signature Block (.DSA) File The .SF file is signed and the signature is placed in the .DSA file. The .DSA file also contains, encoded inside it, the certificate or certificate chain from the keystore which authenticates the public key corresponding to the private key used for signing. Signature Timestamp As of the J2SE 5.0 release, the jarsigner tool can now generate and store a signature timestamp when signing a JAR file. In addition, jarsigner supports alternative signing mechanisms. This behavior is optional and is controlled by the user at the time of signing through these options: o -tsa url o -tsacert alias o -altsigner class o -altsignerpath classpathlist Each of these options is detailed in the Options section below. JAR File Verification A successful JAR file verification occurs if the signature(s) are valid, and none of the files that were in the JAR file when the signatures were generated have been changed since then. JAR file verification involves the following steps: 1. Verify the signature of the .SF file itself. That is, the verification ensures that the signature stored in each signature block (.DSA) file was in fact generated using the private key corresponding to the public key whose certificate (or certificate chain) also appears in the .DSA file. It also ensures that the signature is a valid signature of the corresponding signature (.SF) file, and thus the .SF file has not been tampered with. 2. Verify the digest listed in each entry in the .SF file with each corresponding section in the manifest. The .SF file by default includes a header containing a hash of the entire manifest file. When the header is present, then the verification can check to see whether or not the hash in the header indeed matches the hash of the manifest file. If that is the case, verification proceeds to the next step. If that is not the case, a less optimized verification is required to ensure that the hash in each source file information section in the .SF file equals the hash of its corresponding section in the manifest file (see The Signature (.SF) File). One reason the hash of the manifest file that is stored in the .SF file header may not equal the hash of the current manifest file would be because one or more files were added to the JAR file (using the jar tool) after the signature (and thus the .SF file) was generated. When the jar tool is used to add files, the manifest file is changed (sections are added to it for the new files), but the .SF file is not. A verification is still considered successful if none of the files that were in the JAR file when the signature was generated have been changed since then, which is the case if the hashes in the non-header sections of the .SF file equal the hashes of the corresponding sections in the manifest file. 3. Read each file in the JAR file that has an entry in the .SF file. While reading, compute the file's digest, and then compare the result with the digest for this file in the manifest section. The digests should be the same, or verification fails. If any serious verification failures occur during the verification process, the process is stopped and a security exception is thrown. It is caught and displayed by jarsigner. Multiple Signatures for a JAR File A JAR file can be signed by multiple people simply by running the jarsigner tool on the file multiple times, specifying the alias for a different person each time, as in:   jarsigner myBundle.jar susan\n  jarsigner myBundle.jar kevin\n\n When a JAR file is signed multiple times, there are multiple .SF and .DSA files in the resulting JAR file, one pair for each signature. Thus, in the example above, the output JAR file includes files with the following names:   SUSAN.SF\n  SUSAN.DSA\n  KEVIN.SF\n  KEVIN.DSA\n\n Note: It is also possible for a JAR file to have mixed signatures, some generated by the JDK 1.1 javakey tool and others by jarsigner. That is, jarsigner can be used to sign JAR files already previously signed using javakey.","Process Name":"jarsigner-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jarsigner-java-1.6.0-openjdk"}},{"Process":{"Description":null,"Process Name":"jarsigner-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jarsigner-java-1.7.0-openjdk"}},{"Process":{"Description":"The jasper command converts to and from JPEG-2000 files. Please use the --help command line switch and the JasPer Software Reference Manual for more information.","Process Name":"jasper","Link":"https:\/\/linux.die.net\/man\/1\/jasper"}},{"Process":{"Description":"The java tool launches a Java application. It does this by starting a Java runtime environment, loading a specified class, and invoking that class's main method. The method must be declared public and static, it must not return any value, and it must accept a String array as a parameter. The method declaration must look like the following:     public static void main(String args[])\n\n By default, the first non-option argument is the name of the class to be invoked. A fully-qualified class name should be used. If the -jar option is specified, the first non-option argument is the name of a JAR archive containing class and resource files for the application, with the startup class indicated by the Main-Class manifest header. The Java runtime searches for the startup class, and other classes used, in three sets of locations: the bootstrap class path, the installed extensions, and the user class path. Non-option arguments after the class name or JAR file name are passed to the main function.","Process Name":"java-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/java-java-1.6.0-openjdk"}},{"Process":{"Description":"The java tool launches a Java application. It does this by starting a Java runtime environment, loading a specified class, and invoking that class's main method. The method must be declared public and static, it must not return any value, and it must accept a String array as a parameter. The method declaration must look like the following: public static void main(String args[])\n\n By default, the first non-option argument is the name of the class to be invoked. A fully-qualified class name should be used. If the -jar option is specified, the first non-option argument is the name of a JAR archive containing class and resource files for the application, with the startup class indicated by the Main-Class manifest header. The Java runtime searches for the startup class, and other classes used, in three sets of locations: the bootstrap class path, the installed extensions, and the user class path. Non-option arguments after the class name or JAR file name are passed to the main function.","Process Name":"java-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/java-java-1.7.0-openjdk"}},{"Process":{"Description":null,"Process Name":"javac-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/javac-java-1.6.0-openjdk"}},{"Process":{"Description":"The javac tool reads class and interface definitions, written in the Java programming language, and compiles them into bytecode class files. It can also process annotations in Java source files and classes. There are two ways to pass source code file names to javac: o For a small number of source files, simply list the file names on the command line. o For a large number of source files, list the file names in a file, separated by blanks or line breaks. Then use the list file name on the javac command line, preceded by an @ character. Source code file names must have .java suffixes, class file names must have .class suffixes, and both source and class files must have root names that identify the class. For example, a class called MyClass would be written in a source file called MyClass.java and compiled into a bytecode class file called MyClass.class. Inner class definitions produce additional class files. These class files have names combining the inner and outer class names, such as MyClass$MyInnerClass.class. You should arrange source files in a directory tree that reflects their package tree. For example, if you keep all your source files in \/workspace, the source code for com.mysoft.mypack.MyClass should be in \/workspace\/com\/mysoft\/mypack\/MyClass.java. By default, the compiler puts each class file in the same directory as its source file. You can specify a separate destination directory with -d (see Options, below).","Process Name":"javac-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/javac-java-1.7.0-openjdk"}},{"Process":{"Description":"The Javadoc tool parses the declarations and documentation comments in a set of Java source files and produces a corresponding set of HTML pages describing (by default) the public and protected classes, nested classes (but not anonymous inner classes), interfaces, constructors, methods, and fields. You can use it to generate the API (Application Programming Interface) documentation or the implementation documentation for a set of source files. You can run the Javadoc tool on entire packages, individual source files, or both. When documenting entire packages, you can either use -subpackages for traversing recursively down from a top-level directory, or pass in an explicit list of package names. When documenting individual source files, you pass in a list of source (.java) filenames. Examples are given at the end of this document. How Javadoc processes source files is covered next. Processing of source files The Javadoc tool processes files that end in \" .java\" plus other files described under Source Files. If you run the Javadoc tool by explicitly passing in individual source filenames, you can determine exactly which \" .java\" files are processed. However, that is not how most developers want to work, as it is simpler to pass in package names. The Javadoc tool can be run three ways without explicitly specifying the source filenames. You can (1) pass in package names, (2) use -subpackages, and (3) use wildcards with source filenames ( *.java). In these cases, the Javadoc tool processes a \" .java\" file only if it fulfills all of the following requirements: o Its name, after stripping off the \".java\" suffix, is actually a legal class name (see Identifiers @ http:\/\/java.sun.com\/docs\/books\/jls\/second_edition\/html\/lexical.doc.html#40625 for legal characters) o Its directory path relative to the root of the source tree is actually a legal package name (after converting its separators to dots) o Its package statement contains the legal package name (specified in the previous bullet) Processing of links - During a run, the Javadoc tool automatically adds cross-reference links to package, class and member names that are being documented as part of that run. Links appear in several places: o Declarations (return types, argument types, field types) o \"See Also\" sections generated from @see tags o In-line text generated from {@link} tags o Exception names generated from @throws tags o \"Specified by\" links to members in interfaces and \"Overrides\" links to members in classes o Summary tables listing packages, classes and members o Package and class inheritance trees o The index You can add hyperlinks to existing text for classes not included on the command line (but generated separately) by way of the -link and -linkoffline options. Other processing details - The Javadoc tool produces one complete document each time it is run; it cannot do incremental builds -- that is, it cannot modify or directly incorporate results from previous runs of the Javadoc tool. However, it can link to results from other runs, as just mentioned. As implemented, the Javadoc tool requires and relies on the java compiler to do its job. The Javadoc tool calls part of javac to compile the declarations, ignoring the member implementation. It builds a rich internal representation of the classes, including the class hierarchy, and \"use\" relationships, then generates the HTML from that. The Javadoc tool also picks up user-supplied documentation from documentation comments in the source code. In fact, the Javadoc tool will run on .java source files that are pure stub files with no method bodies. This means you can write documentation comments and run the Javadoc tool in the earliest stages of design while creating the API, before writing the implementation. Relying on the compiler ensures that the HTML output corresponds exactly with the actual implementation, which may rely on implicit, rather than explicit, source code. For example, the Javadoc tool documents default constructors @ http:\/\/java.sun.com\/docs\/books\/jls\/second_edition\/html\/names.doc.html#36154 (section 8.6.7 of Java Language Specification) that are present in the .class files but not in the source code. In many cases, the Javadoc tool allows you to generate documentation for source files whose code is incomplete or erroneous. This is a benefit that enables you to generate documentation before all debugging and troubleshooting is done. For example, according to the Java Language Specification, a class that contains an abstract method should itself be declared abstract. The Javadoc tool does not check for this, and would proceed without a warning, whereas the javac compiler stops on this error. The Javadoc tool does do some primitive checking of doc comments. Use the DocCheck doclet to check the doc comments more thoroughly. When the Javadoc tool builds its internal structure for the documentation, it loads all referenced classes. Because of this, the Javadoc tool must be able to find all referenced classes, whether bootstrap classes, extensions, or user classes. For more about this, see How Classes Are Found. Generally speaking, classes you create must either be loaded as an extension or in the Javadoc tool's class path. Javadoc Doclets You can customize the content and format of the Javadoc tool's output by using doclets. The Javadoc tool has a default \"built-in\" doclet, called the standard doclet, that generates HTML-formatted API documentation. You can modify or subclass the standard doclet, or write your own doclet to generate HTML, XML, MIF, RTF or whatever output format you'd like. Information about doclets and their use is at the following locations: o Javadoc Doclets o The -doclet command-line option When a custom doclet is not specified with the -doclet command line option, the Javadoc tool will use the default standard doclet. The javadoc tool has several command line options that are available regardless of which doclet is being used. The standard doclet adds a supplementary set of command line options. Both sets of options are described below in the options section. Related Documentation and Doclets o Javadoc Enhancements for details about improvements added in Javadoc. o Javadoc FAQ @ http:\/\/java.sun.com\/j2se\/javadoc\/faq\/index.html for answers to common questions, information about Javadoc-related tools, and workarounds for bugs. o How to Write Doc Comments for Javadoc @ http:\/\/java.sun.com\/j2se\/javadoc\/writingdoccomments\/index.html for more information about Sun conventions for writing documentation comments. o Requirements for Writing API Specifications @ http:\/\/java.sun.com\/j2se\/javadoc\/writingapispecs\/index.html - Standard requirements used when writing the Java 2 Platform Specification. It can be useful whether you are writing API specifications in source file documentation comments or in other formats. It covers requirements for packages, classes, interfaces, fields and methods to satisfy testable assertions. o Documentation Comment Specification @ http:\/\/java.sun.com\/docs\/books\/jls\/first_edition\/html\/18.doc.html - The original specification on documentation comments, Chapter 18, Documentation Comments, in the Java Language Specification, First Edition, by James Gosling, Bill Joy, and Guy Steele. (This chapter was removed from the second edition.) o DocCheck Doclet @ http:\/\/java.sun.com\/javadoc\/doccheck - Checks doc comments in source files and generates a report listing the errors and irregularities it finds. It is part of the Sun Doc Check Utilities. o MIF Doclet @ http:\/\/java.sun.com\/javadoc\/mifdoclet - Can automate the generation of API documentation in MIF, FrameMaker and PDF formats. MIF is Adobe FrameMaker's interchange format. Terminology The terms documentation comment, doc comment, main description, tag, block tag, and in-line tag are described at Documentation Comments. These other terms have specific meanings within the context of the Javadoc tool: generated document The document generated by the javadoc tool from the doc comments in Java source code. The default generated document is in HTML and is created by the standard doclet. name A name of a program element written in the Java Language -- that is, the name of a package, class, interface, field, constructor or method. A name can be fully-qualified, such as java.lang.String.equals(java.lang.Object), or partially-qualified, such as equals(Object). documented classes The classes and interfaces for which detailed documentation is generated during a javadoc run. To be documented, the source files must be available, their source filenames or package names must be passed into the javadoc command, and they must not be filtered out by their access modifier (public, protected, package-private or private). We also refer to these as the classes included in the javadoc output, or the included classes. included classes Classes and interfaces whose details are documented during a run of the Javadoc tool. Same as documented classes. excluded classes Classes and interfaces whose details are not documented during a run of the Javadoc tool. referenced classes The classes and interfaces that are explicitly referred to in the definition (implementation) or doc comments of the documented classes and interfaces. Examples of references include return type, parameter type, cast type, extended class, implemented interface, imported classes, classes used in method bodies, @see, {@link}, {@linkplain}, and {@inheritDoc} tags. (Notice this definition has changed since 1.3 @ http:\/\/java.sun.com\/j2se\/1.3\/docs\/tooldocs\/solaris\/javadoc.html#referencedclasses.) When the Javadoc tool is run, it should load into memory all of the referenced classes in javadoc's bootclasspath and classpath. (The Javadoc tool prints a \"Class not found\" warning for referenced classes not found.) The Javadoc tool can derive enough information from the .class files to determine their existence and the fully-qualified names of their members. external referenced classes The referenced classes whose documentation is not being generated during a javadoc run. In other words, these classes are not passed into the Javadoc tool on the command line. Links in the generated documentation to those classes are said to be external references or external links. For example, if you run the Javadoc tool on only the java.awt package, then any class in java.lang, such as Object, is an external referenced class. External referenced classes can be linked to using the -link and -linkoffline options. An important property of an external referenced class is that its source comments are normally not available to the Javadoc run. In this case, these comments cannot be inherited.","Process Name":"javadoc-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/javadoc-java-1.6.0-openjdk"}},{"Process":{"Description":null,"Process Name":"javadoc-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/javadoc-java-1.7.0-openjdk"}},{"Process":{"Description":"javah generates C header and source files that are needed to implement native methods. The generated header and source files are used by C programs to reference an object's instance variables from native source code. The .h file contains a struct definition whose layout parallels the layout of the corresponding class. The fields in the struct correspond to instance variables in the class. The name of the header file and the structure declared within it are derived from the name of the class. If the class passed to javah is inside a package, the package name is prepended to both the header file name and the structure name. Underscores (_) are used as name delimiters. By default javah creates a header file for each class listed on the command line and puts the files in the current directory. Use the -stubs option to create source files. Use the -o option to concatenate the results for all listed classes into a single file. The new native method interface, Java Native Interface (JNI), does not require header information or stub files. javah can still be used to generate native method function proptotypes needed for JNI-style native methods. javah produces JNI-style output by default, and places the result in the .h file. javah_g is a non-optimized version of javah suitable for use with debuggers like jdb.","Process Name":"javah-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/javah-java-1.6.0-openjdk"}},{"Process":{"Description":"javah generates C header and source files that are needed to implement native methods. The generated header and source files are used by C programs to reference an object's instance variables from native source code. The .h file contains a struct definition whose layout parallels the layout of the corresponding class. The fields in the struct correspond to instance variables in the class. The name of the header file and the structure declared within it are derived from the name of the class. If the class passed to javah is inside a package, the package name is prepended to both the header file name and the structure name. Underscores (_) are used as name delimiters. By default javah creates a header file for each class listed on the command line and puts the files in the current directory. Use the -stubs option to create source files. Use the -o option to concatenate the results for all listed classes into a single file. The new native method interface, Java Native Interface (JNI), does not require header information or stub files. javah can still be used to generate native method function proptotypes needed for JNI-style native methods. javah produces JNI-style output by default, and places the result in the .h file.","Process Name":"javah-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/javah-java-1.7.0-openjdk"}},{"Process":{"Description":"The javap command disassembles a class file. Its output depends on the options used. If no options are used, javap prints out the package, protected, and public fields and methods of the classes passed to it. javap prints its output to stdout. For example, compile the following class declaration: import java.awt.*;\nimport java.applet.*;\n\npublic class DocFooter extends Applet {\n        String date;\n        String email;\n\n       public void init() {\n                resize(500,100);\n                date = getParameter(\"LAST_UPDATED\");\n                email = getParameter(\"EMAIL\");\n        }\n\n       public void paint(Graphics g) {\n                g.drawString(date + \" by \",100, 15);\n                g.drawString(email,290,15);\n        }\n}\n\n The output from javap DocFooter yields: Compiled from DocFooter.java\npublic class DocFooter extends java.applet.Applet {\n    java.lang.String date;\n    java.lang.String email;\n    public DocFooter();\n    public void init();\n    public void paint(java.awt.Graphics);\n}\n\n The output from javap -c DocFooter yields: Compiled from DocFooter.java\npublic class DocFooter extends java.applet.Applet {\n    java.lang.String date;\n    java.lang.String email;\n    public DocFooter();\n    public void init();\n    public void paint(java.awt.Graphics);\n}\n\nMethod DocFooter()\n   0 aload_0\n   1 invokespecial #1 <Method java.applet.Applet()>\n   4 return\n\nMethod void init()\n   0 aload_0\n   1 sipush 500\n   4 bipush 100\n   6 invokevirtual #2 <Method void resize(int, int)>\n   9 aload_0\n  10 aload_0\n  11 ldc #3 <String \"LAST_UPDATED\">\n  13 invokevirtual #4 <Method java.lang.String getParameter(java.lang.String)>\n  16 putfield #5 <Field java.lang.String date>\n  19 aload_0\n  20 aload_0\n  21 ldc #6 <String \"EMAIL\">\n  23 invokevirtual #4 <Method java.lang.String getParameter(java.lang.String)>\n  26 putfield #7 <Field java.lang.String email>\n  29 return\n\nMethod void paint(java.awt.Graphics)\n   0 aload_1\n   1 new #8 <Class java.lang.StringBuffer>\n   4 dup\n   5 invokespecial #9 <Method java.lang.StringBuffer()>\n   8 aload_0\n   9 getfield #5 <Field java.lang.String date>\n  12 invokevirtual #10 <Method java.lang.StringBuffer append(java.lang.String)>\n  15 ldc #11 <String \" by \">\n  17 invokevirtual #10 <Method java.lang.StringBuffer append(java.lang.String)>\n  20 invokevirtual #12 <Method java.lang.String toString()>\n  23 bipush 100\n  25 bipush 15\n  27 invokevirtual #13 <Method void drawString(java.lang.String, int, int)>\n  30 aload_1\n  31 aload_0\n  32 getfield #7 <Field java.lang.String email>\n  35 sipush 290\n  38 bipush 15\n  40 invokevirtual #13 <Method void drawString(java.lang.String, int, int)>\n  43 return","Process Name":"javap-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/javap-java-1.6.0-openjdk"}},{"Process":{"Description":null,"Process Name":"javap-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/javap-java-1.7.0-openjdk"}},{"Process":{"Description":"javaws is an implementation of a JNLP client. It uses a JNLP (Java Network Launch Protocol) file to securely run a remote Java application or a Java applet. This implementation of javaws is from the IcedTea project and is based on the NetX project. A JNLP file is an xml file that describes how to securely run a remote Java application or a Java applet.","Process Name":"javaws-itweb","Link":"https:\/\/linux.die.net\/man\/1\/javaws-itweb"}},{"Process":{"Description":"This program is part of Netpbm(1). jbigtopnm reads a JBIG bi-level image entity (BIE) from a file or standard input, decompresses it, and outputs a PBM or PGM file. If the input has one plane, or you choose just one plane of it, the output is PBM. Otherwise, the output is PGM. JBIG is a highly effective lossless compression algorithm for bi-level images (one bit per pixel), which is particularly suitable for scanned document pages. A JBIG encoded image can be stored in several resolutions in one or several BIEs. All resolution layers except the lowest one are stored efficiently as differences to the next lower resolution layer. You can use options -x and -y to stop the decompression at a specified maximal output image size. The input file can consist of several concatenated BIEs which contain different increasing resolution layers of the same image.","Process Name":"jbigtopnm","Link":"https:\/\/linux.die.net\/man\/1\/jbigtopnm"}},{"Process":{"Description":"This is a class file examiner, similar to \"javap\". It will print information about a number of classes, which are specified by class name or file name.","Process Name":"jcf-dump","Link":"https:\/\/linux.die.net\/man\/1\/jcf-dump"}},{"Process":{"Description":"jcmd is a utility to send diagnostic command requests to a Java Virtual Machine supporting this feature. Used without arguments or with the -l option, jcmd prints the list of running Java processes with their process id, their main class and their command line arguments. When a process id is specified on the command line, jcmd sends the diagnostic command request to the process with this id. When a main class is specified on the command line, jcmd sends the diagnostic command request to all Java processes for which the command line argument is a substring of the Java process' main class. With the PerfCounter.print argument, jcmd prints the performance counters available on the targeted Java process(es). With the -f option, jcmd sends to the targeted Java process(es) the diagnostic commands stored in the file file.","Process Name":"jcmd-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jcmd-java-1.7.0-openjdk"}},{"Process":{"Description":null,"Process Name":"jconsole-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jconsole-java-1.6.0-openjdk"}},{"Process":{"Description":"The jconsole command launches a graphical console tool that enables you to monitor and manage Java applications and virtual machines on a local or remote machine. On Windows, jconsole does not associate with a console window. It will, however, display a dialog box with error information if the jconsole command fails for some reason.","Process Name":"jconsole-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jconsole-java-1.7.0-openjdk"}},{"Process":{"Description":"jday and j2d are command line utilities to convert calendar dates to astronomical julian dates, and julian dates to calendar dates. There is a corresponding library libjday.a which can be used for the same functionality within applications.","Process Name":"jday","Link":"https:\/\/linux.die.net\/man\/1\/jday"}},{"Process":{"Description":null,"Process Name":"jdb-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jdb-java-1.6.0-openjdk"}},{"Process":{"Description":"The Java Debugger, jdb, is a simple command-line debugger for Java classes. It is a demonstration of the Java Platform Debugger Architecture @ http:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/jpda\/index.html that provides inspection and debugging of a local or remote Java Virtual Machine. Starting a jdb Session There are many ways to start a jdb session. The most frequently used way is to have jdb launch a new Java Virtual Machine (VM) with the main class of the application to be debugged. This is done by substituting the command jdb for java in the command line. For example, if your application's main class is MyClass, you use the following command to debug it under JDB:  % jdb MyClass\n\n When started this way, jdb invokes a second Java VM with any specified parameters, loads the specified class, and stops the VM before executing that class's first instruction. Another way to use jdb is by attaching it to a Java VM that is already running. Syntax for Starting a VM to which jdb will attach when the VM is running is as follows. This loads in-process debugging libraries and specifies the kind of connection to be made. -agentlib:jdwp=transport=dt_socket,server=y,suspend=n\n\n For example, the following command will run the MyClass application, and allow jdb to connect to it at a later time.  % java -agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n MyClass\n\n You can then attach jdb to the VM with the following commmand:  % jdb -attach 8000\n\n Note that \"MyClass\" is not specified in the jdb command line in this case because jdb is connecting to an existing VM instead of launching a new one. There are many other ways to connect the debugger to a VM, and all of them are supported by jdb. The Java Platform Debugger Architecture has additional documentation @ http:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/jpda\/conninv.html on these connection options. For information on starting a J2SE 1.4.2 or early VM for use with jdb see the 1.4.2 documentation @ http:\/\/java.sun.com\/j2se\/1.4.2\/docs\/guide\/jpda\/conninv.html Basic jdb Commands The following is a list of the basic jdb commands. The Java debugger supports other commands which you can list using jdb's help command. help, or ? The most important jdb command, help displays the list of recognized commands with a brief description. run After starting jdb, and setting any necessary breakpoints, you can use this command to start the execution the debugged application. This command is available only when jdb launches the debugged application (as opposed to attaching to an existing VM). cont Continues execution of the debugged application after a breakpoint, exception, or step. print Displays Java objects and primitive values. For variables or fields of primitive types, the actual value is printed. For objects, a short description is printed. See the dump command below for getting more information about an object. NOTE: To display local variables, the containing class must have been compiled with the javac(1) -g option. print supports many simple Java expressions including those with method invocations, for example: o print MyClass.myStaticField o print myObj.myInstanceField o print i + j + k (i, j, k are primities and either fields or local variables) o print myObj.myMethod() (if myMethod returns a non-null) o print new java.lang.String(\"Hello\").length() dump For primitive values, this command is identical to print. For objects, it prints the current value of each field defined in the object. Static and instance fields are included. The dump command supports the same set of expressions as the print command. threads List the threads that are currently running. For each thread, its name and current status are printed, as well as an index that can be used for other commands, for example: 4. (java.lang.Thread)0x1 main      running\n\n In this example, the thread index is 4, the thread is an instance of java.lang.Thread, the thread name is \"main\", and it is currently running, thread Select a thread to be the current thread. Many jdb commands are based on the setting of the current thread. The thread is specified with the thread index described in the threads command above. where where with no arguments dumps the stack of the current thread. where all dumps the stack of all threads in the current thread group. where threadindex dumps the stack of the specified thread. If the current thread is suspended (either through an event such as a breakpoint or through the suspend command), local variables and fields can be displayed with the print and dump commands. The up and down commands select which stack frame is current. Breakpoints Breakpoints can be set in jdb at line numbers or at the first instruction of a method, for example: o stop at MyClass:22 (sets a breakpoint at the first instruction for line 22 of the source file containing MyClass) o stop in java.lang.String.length (sets a breakpoint at the beginnig of the method java.lang.String.length) o stop in MyClass.<init> (<init> identifies the MyClass constructor) o stop in MyClass.<clinit> (<clinit> identifies the static initialization code for MyClass) If a method is overloaded, you must also specify its argument types so that the proper method can be selected for a breakpoint. For example, \" MyClass.myMethod(int,java.lang.String)\", or \" MyClass.myMethod()\". The clear command removes breakpoints using a syntax as in \"clear MyClass:45\". Using the clear or command with no argument displays a list of all breakpoints currently set. The cont command continues execution. Stepping The step commands advances execution to the next line whether it is in the current stack frame or a called method. The next command advances execution to the next line in the current stack frame. Exceptions When an exception occurs for which there isn't a catch statement anywhere in the throwing thread's call stack, the VM normally prints an exception trace and exits. When running under jdb, however, control returns to jdb at the offending throw. You can then use jdb to diagnose the cause of the exception. Use the catch command to cause the debugged application to stop at other thrown exceptions, for example: \"catch java.io.FileNotFoundException\" or \"catch mypackage.BigTroubleException. Any exception which is an instance of the specifield class (or of a subclass) will stop the application at the point where it is thrown. The ignore command negates the effect of a previous catch command. NOTE: The ignore command does not cause the debugged VM to ignore specific exceptions, only the debugger.","Process Name":"jdb-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jdb-java-1.7.0-openjdk"}},{"Process":{"Description":null,"Process Name":"jedit","Link":"https:\/\/linux.die.net\/man\/1\/jedit"}},{"Process":{"Description":"rancid is a perl(1) script which uses the login scripts (see clogin(1)) to login to a device, execute commands to display the configuration, etc, then filters the output for formatting, security, and so on. rancid's product is a file with the name of it's last argument plus the suffix .new. For example, hostname.new. There are complementary scripts for other platforms and\/or manufacturers that are supported by rancid(1). Briefly, these are: agmrancid Cisco Anomaly Guard Module (AGM) arancid Alteon WebOS switches arrancid Arista Networks devices brancid Bay Networks (nortel) cat5rancid Cisco catalyst switches cssrancid Cisco content services switches erancid ADC-kentrox EZ-T3 mux f10rancid Force10 f5rancid F5 BigIPs fnrancid Fortinet Firewalls francid Foundry and HP procurve OEMs of Foundry hrancid HP Procurve Switches htranicd Hitachi Routers jerancid Juniper Networks E-series jrancid Juniper Networks mrancid MRTd mrvrancid MRV optical switches nrancid Netscreen firewalls nsrancid Netscaler nxrancid Cisco Nexus boxes prancid Procket Networks rivrancid Riverstone rrancid Redback srancid SMC switch (some Dell OEMs) trancid Netopia sDSL\/T1 routers tntrancid Lucent TNT xrancid Extreme switches xrrancid Cisco IOS-XR boxes zrancid Zebra routing software The command-line options are as follows: -V Prints package name and version strings. -d Display debugging information. -l Display somewhat less debugging information. -f rancid should interpret the next argument as a filename which contains the output it would normally collect from the device ( hostname) with clogin(1).","Process Name":"jerancid","Link":"https:\/\/linux.die.net\/man\/1\/jerancid"}},{"Process":{"Description":null,"Process Name":"jhat-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jhat-java-1.6.0-openjdk"}},{"Process":{"Description":"The jhat command parses a java heap dump file and launches a webserver. jhat enables you to browse heap dumps using your favorite webbrowser. jhat supports pre-designed queries (such as 'show all instances of a known class \"Foo\"') as well as OQL (Object Query Language) - a SQL-like query language to query heap dumps. Help on OQL is available from the OQL help page shown by jhat. With the default port, OQL help is available at http:\/\/localhost:7000\/oqlhelp\/ There are several ways to generate a java heap dump: o Use jmap(1) -dump option to obtain a heap dump at runtime; o Use jconsole(1) option to obtain a heap dump via HotSpotDiagnosticMXBean @ http:\/\/docs.oracle.com\/javase\/7\/docs\/jre\/api\/management\/extension\/com\/sun\/management\/HotSpotDiagnosticMXBean.html at runtime; o Heap dump will be generated when OutOfMemoryError is thrown by specifying -XX:+HeapDumpOnOutOfMemoryError VM option; o Use hprof @ http:\/\/java.sun.com\/developer\/technicalArticles\/Programming\/HPROF.html. NOTE: This tool is experimental and may not be available in future versions of the JDK.","Process Name":"jhat-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jhat-java-1.7.0-openjdk"}},{"Process":{"Description":"jhead is used to display and manipulate data contained in the Exif header of JPEG images from digital cameras. By default, jhead displays the more useful camera settings from the file in a user-friendly format. jhead can also be used to manipulate some aspects of the image relating to JPEG and Exif headers, such as changing the internal timestamps, removing the thumbnail, or transferring Exif headers back into edited images after graphical editors deleted the Exif header. jhead can also be used to launch other programs, similar in style to the UNIX find command, but much simpler.","Process Name":"jhead","Link":"https:\/\/linux.die.net\/man\/1\/jhead"}},{"Process":{"Description":"BETA version of the jigdo download manager. This version is not yet capable of processing '.jigdo' files - use jigdo-lite(1) for that. jigdo is a GTK+ download manager with FTP and HTTP 1.1 pipelining support, pausing, continuing and resuming of downloads, and automatic guessing of your proxy configuration.","Process Name":"jigdo","Link":"https:\/\/linux.die.net\/man\/1\/jigdo"}},{"Process":{"Description":"Jigsaw Download, or short jigdo, is a scheme developed primarily to make it easy to distribute huge filesystem images (e.g. CD (ISO9660) or DVD (UDF) images) over the internet, but it could also be used for other data which is awkward to handle due to its size, like audio\/video files or large software packages. jigdo tries to ensure that the large file (always called image from now on) is downloaded in small parts which can be stored on different servers. People who want to download the image do so by telling the jigdo(1) (NOT IMPLEMENTED YET) download tool to process one '.jigdo' file; using it, jigdo downloads the parts and reassembles the image. jigdo-file is used to prepare the files for download. What makes jigdo special is that the parts that are used to reconstruct the image can have any size and content - they only need to be contained in a contiguous region anywhere in the image. For example, if you wish to distribute an ISO9660 image which contains a snapshot of an FTP server, you can instruct jigdo-file to prepare the download data in such a way that when people use jigdo to download the image, jigdo actually fetches the individual files from the FTP server and assembles them into an exact copy of your image - during the download! (If the image is not a filesystem dump, you can use split(1) to create the small parts that the image will be reassembled from.) You are completely free to choose where the individual parts of the image are stored: They may be in entirely different directories on different servers (e.g. because of storage\/bandwidth constraints), but this is invisible to the people downloading your image. The information about available servers only needs to be added to the '.jigdo' file by you before distributing it. The 'DETAILS' section below contains technical details on how jigdo works. The 'EXAMPLES' section lists a number of common scenarios and may help you to get an idea of what jigdo is useful for.","Process Name":"jigdo-file","Link":"https:\/\/linux.die.net\/man\/1\/jigdo-file"}},{"Process":{"Description":null,"Process Name":"jigdo-lite","Link":"https:\/\/linux.die.net\/man\/1\/jigdo-lite"}},{"Process":{"Description":"See jigdo-file(1) for an introduction to Jigsaw Download. jigdo-mirror is a script intended for people who want to offer direct HTTP or FTP downloads of files for which only the jigdo and template files are available. As the first step of using jigdo-mirror, you need to set up normal HTTP\/FTP\/rsync mirroring both of the '.jigdo'\/'.template' files and of the parts that are needed for the reconstruction of the images. For example, in the case that you want to mirror Debian CD images with jigdo-mirror, you need a mirror of the '.jigdo'\/'.template' files and a Debian mirror on the local machine. At regular intervals (preferably immediately after the normal mirroring has finished), schedule a run of jigdo-mirror. It will search through a given directory for any '.jigdo' files and attempt to create all images offered by each file. The script requires you to set a number of variables - please refer to the start of \/usr\/bin\/jigdo-mirror for a description of each of them. Since \/usr\/bin\/jigdo-mirror will be overwritten whenever you upgrade jigdo-mirror, it is highly recommended not to change the settings directly in this script. Instead, personal settings should be saved in a file called .jigdo-mirror in your home directory, or in a different file whose name is then passed to the script as its first (and only) command line argument.","Process Name":"jigdo-mirror","Link":"https:\/\/linux.die.net\/man\/1\/jigdo-mirror"}},{"Process":{"Description":null,"Process Name":"jigglypuff","Link":"https:\/\/linux.die.net\/man\/1\/jigglypuff"}},{"Process":{"Description":"The jigsaw program takes an image, carves it up into a jigsaw puzzle, shuffles it, and then solves it. The image that it manipulates will be grabbed from the portion of the screen underlying the window, or from the system's video input, or from a random file on disk, as indicated by the grabDesktopImages, grabVideoFrames, and chooseRandomImages options in the ~\/.xscreensaver file; see xscreensaver-demo(1) for more details.","Process Name":"jigsaw","Link":"https:\/\/linux.die.net\/man\/1\/jigsaw"}},{"Process":{"Description":"jinfo prints Java configuration information for a given Java process or core file or a remote debug server. Configuration information includes Java System properties and Java virtual machine command line flags. If the given process is running on a 64-bit VM, you may need to specify the -J-d64 option, e.g.: jinfo -J-d64 -sysprops pid NOTE - This utility is unsupported and may or may not be available in future versions of the JDK. On Windows, jinfo only supports the -flag option of a running process.","Process Name":"jinfo-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jinfo-java-1.6.0-openjdk"}},{"Process":{"Description":null,"Process Name":"jinfo-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jinfo-java-1.7.0-openjdk"}},{"Process":{"Description":"The jiv command displays a JPEG-2000 image on an X display. Use the arrow keys for scrolling and < and > for zooming. Please use the --help command line switch and the JasPer Software Reference Manual for more information.","Process Name":"jiv","Link":"https:\/\/linux.die.net\/man\/1\/jiv"}},{"Process":{"Description":"Command line application for gracefully putting hosts into and out of rotation in a modjk balancer.","Process Name":"jk-rotate","Link":"https:\/\/linux.die.net\/man\/1\/jk-rotate"}},{"Process":{"Description":"The jlayout program reads a GUI description from the input file. The structure of the input file is explained below. The output operation is to modify a Java source code file. Regions of this file -- marked up by special comments -- are replaced by new code to create the GUI .","Process Name":"jlayout","Link":"https:\/\/linux.die.net\/man\/1\/jlayout"}},{"Process":{"Description":null,"Process Name":"jlogin","Link":"https:\/\/linux.die.net\/man\/1\/jlogin"}},{"Process":{"Description":"JOE is a powerful ASCII-text screen editor. It has a \"mode-less\" user interface which is similar to many user-friendly PC editors. Users of Micro-Pro's WordStar or Borland's \"Turbo\" languages will feel at home. JOE is a full featured UNIX screen-editor though, and has many features for editing programs and text. JOE also emulates several other editors. JSTAR is a close imitation of WordStar with many \"JOE\" extensions. JPICO is a close imitation of the Pine mailing system's PICO editor, but with many extensions and improvements. JMACS is a GNU-EMACS imitation. RJOE is a restricted version of JOE, which allows you to edit only the files specified on the command line. Although JOE is actually five different editors, it still requires only one executable, but one with five different names. The name of the editor with an \"rc\" appended gives the name of JOE's initialization file, which determines the personality of the editor. JOE is free software; you can distribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation. I have no plans for turning JOE into a commercial or share-ware product. JOE is available over the Internet from www.sourceforge.net\/projects\/joe-editor.","Process Name":"jmacs","Link":"https:\/\/linux.die.net\/man\/1\/jmacs"}},{"Process":{"Description":"jmap prints shared object memory maps or heap memory details of a given process or core file or a remote debug server. If the given process is running on a 64-bit VM, you may need to specify the -J-d64 option, e.g.: jmap -J-d64 -heap pid\n\n NOTE - This utility is unsupported and may or may not be available in future versions of the JDK. The only forms of jmap available on the Windows platform are jmap -dump:< dump-options> pid and jmap -histo[:live] pid","Process Name":"jmap-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jmap-java-1.6.0-openjdk"}},{"Process":{"Description":null,"Process Name":"jmap-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jmap-java-1.7.0-openjdk"}},{"Process":{"Description":"","Process Name":"jobs","Link":"https:\/\/linux.die.net\/man\/1\/jobs"}},{"Process":{"Description":null,"Process Name":"joe","Link":"https:\/\/linux.die.net\/man\/1\/joe"}},{"Process":{"Description":"For each pair of input lines with identical join fields, write a line to standard output. The default join field is the first, delimited by whitespace. When FILE1 or FILE2 (not both) is -, read standard input. -a FILENUM print unpairable lines coming from file FILENUM, where FILENUM is 1 or 2, corresponding to FILE1 or FILE2 -e EMPTY replace missing input fields with EMPTY -i, --ignore-case ignore differences in case when comparing fields -j FIELD equivalent to '-1 FIELD -2 FIELD' -o FORMAT obey FORMAT while constructing output line -t CHAR use CHAR as input and output field separator -v FILENUM like -a FILENUM, but suppress joined output lines -1 FIELD join on this FIELD of file 1 -2 FIELD join on this FIELD of file 2 --check-order check that the input is correctly sorted, even if all input lines are pairable --nocheck-order do not check that the input is correctly sorted --help display this help and exit --version output version information and exit Unless -t CHAR is given, leading blanks separate fields and are ignored, else fields are separated by CHAR. Any FIELD is a field number counted from 1. FORMAT is one or more comma or blank separated specifications, each being 'FILENUM.FIELD' or '0'. Default FORMAT outputs the join field, the remaining fields from FILE1, the remaining fields from FILE2, all separated by CHAR. Important: FILE1 and FILE2 must be sorted on the join fields. E.g., use 'sort -k 1b,1' if 'join' has no options. Note, comparisons honor the rules specified by 'LC_COLLATE'. If the input is not sorted and some lines cannot be joined, a warning message will be given.","Process Name":"join","Link":"https:\/\/linux.die.net\/man\/1\/join"}},{"Process":{"Description":"joinpipe(1) joins volumes generated by splitpipe(1) to standard output. In doing so, it checks the proper order of inserted volumes, if these volumes all belong to the same backup session. Integrity of data is verified using a running checksum, currently MD5. Volumes are read from the devices or filenames specified on the command line. When passing multiple names, the first volume is read from the first name, the second volume from the second name etc. When there are more volumes than names, remaining volumes are read in from the last name specified.","Process Name":"joinpipe","Link":"https:\/\/linux.die.net\/man\/1\/joinpipe"}},{"Process":{"Description":"JOVE is Jonathan's Own Version of Emacs. It is based on the original EMACS editor written at MIT by Richard Stallman. Although JOVE is meant to be compatible with EMACS, there are some major differences between the two editors and you shouldn't rely on their behaving identically. JOVE works on any reasonable display terminal that is described in the termcap file (see termcap(5) for more details). When you start up JOVE, it checks to see whether you have your TERM environment variable set. On most systems that will automatically be set up for you, but if it's not JOVE will ask you what kind of terminal you are using. To avoid having to type this every time you run JOVE you can set your TERM environment variable yourself. How you do this depends on which shell you are running. If you are running the C Shell, as most of you are, you type % setenv TERM type and with the Bourne Shell, you type $ TERM= type ; export TERM where type is the name of the kind of terminal you are using (e.g., vt100). If neither of these works get somebody to help you.","Process Name":"jove","Link":"https:\/\/linux.die.net\/man\/1\/jove"}},{"Process":{"Description":null,"Process Name":"jpeg2ktopam","Link":"https:\/\/linux.die.net\/man\/1\/jpeg2ktopam"}},{"Process":{"Description":null,"Process Name":"jpeg2swf","Link":"https:\/\/linux.die.net\/man\/1\/jpeg2swf"}},{"Process":{"Description":"jpeg2yuv decompresses a sequence of JPEG files and pipes the image data to stdout as a YUV4MPEG2 stream. Any JPEG format supported by libjpeg can be read. stdout will be filled with the YUV4MPEG2 movie data stream, so be prepared to pipe it on to mpeg2enc or to write it into a file.","Process Name":"jpeg2yuv","Link":"https:\/\/linux.die.net\/man\/1\/jpeg2yuv"}},{"Process":{"Description":"Jpeghotp automatically finds hot pixels in an otherwise black JPEG image (default) or dead pixels in an otherwise white JPEG image (if the --invert option is specified). The output is suitable as a pixel block specification file for the jpegpixi(1) program. A typical application is to process an image taken with a digital camera with CCD defects. To obtain a black image, take a picture in total darkness or with covered lens. To obtain a while image, take an overexposed picture of a well-lit piece of white paper. JPEG-FILE is the filename of the JPEG image to read. It can be -, which refers to standard input. PIXEL-BLOCKS-FILE is the name of the file to write the coordinates and sizes of the hot (or dead) pixel blocks to. If it is omitted, the coordinates and sizes are written to standard output.","Process Name":"jpeghotp","Link":"https:\/\/linux.die.net\/man\/1\/jpeghotp"}},{"Process":{"Description":null,"Process Name":"jpegicc","Link":"https:\/\/linux.die.net\/man\/1\/jpegicc"}},{"Process":{"Description":"Jpegpixi interpolates pixels or pixel blocks in JFIF images files (commonly referred to as \"JPEG images\"). This is useful to correct images from a digital camera with CCD defects. Only DCT blocks which contain pixels to be interpolated are decoded and re-encoded, and the re-encoding is performed with exactly the same parameters with which the image has originally been encoded. Therefore, the image quality is preserved as much as possible. SOURCE and DEST are the filenames of the source file and the destination file, respectively. In both cases, - can be used, which refers to standard input or standard output. The destination filename is followed by any number of pixel or pixel block specifications. It starts with an optional direction specifier (D), which can be 2 for 2-dimensional interpolation (the default), V or v for 1-dimensional vertical interpolation (e.g. to remove horizontal stripes), or H or h for 1-dimensional horizontal interpolation. X,Y are the coordinates of the pixel or the upper-left corner of the pixel block. S is the size of the pixel block (1 by default). Alternatively, separate sizes can be specified for the width (SX) and the height (SY). All numbers (X, Y, S, SX, SY) can be expressed as absolute coordinates\/sizes or percentages of the image size. If a number is followed by a percent character (%), it is interpreted as a percentage, otherwise as an absolute number.","Process Name":"jpegpixi","Link":"https:\/\/linux.die.net\/man\/1\/jpegpixi"}},{"Process":{"Description":null,"Process Name":"jpegtoexr","Link":"https:\/\/linux.die.net\/man\/1\/jpegtoexr"}},{"Process":{"Description":null,"Process Name":"jpegtopnm","Link":"https:\/\/linux.die.net\/man\/1\/jpegtopnm"}},{"Process":{"Description":null,"Process Name":"jpegtran","Link":"https:\/\/linux.die.net\/man\/1\/jpegtran"}},{"Process":{"Description":"lcms is a standalone CMM engine, which deals with the color management. It implements a fast transformation between ICC profiles. jpegicc is little cms ICC profile applier for JPEG.","Process Name":"jpgicc2","Link":"https:\/\/linux.die.net\/man\/1\/jpgicc2"}},{"Process":{"Description":"JOE is a powerful ASCII-text screen editor. It has a \"mode-less\" user interface which is similar to many user-friendly PC editors. Users of Micro-Pro's WordStar or Borland's \"Turbo\" languages will feel at home. JOE is a full featured UNIX screen-editor though, and has many features for editing programs and text. JOE also emulates several other editors. JSTAR is a close imitation of WordStar with many \"JOE\" extensions. JPICO is a close imitation of the Pine mailing system's PICO editor, but with many extensions and improvements. JMACS is a GNU-EMACS imitation. RJOE is a restricted version of JOE, which allows you to edit only the files specified on the command line. Although JOE is actually five different editors, it still requires only one executable, but one with five different names. The name of the editor with an \"rc\" appended gives the name of JOE's initialization file, which determines the personality of the editor. JOE is free software; you can distribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation. I have no plans for turning JOE into a commercial or share-ware product. JOE is available over the Internet from www.sourceforge.net\/projects\/joe-editor.","Process Name":"jpico","Link":"https:\/\/linux.die.net\/man\/1\/jpico"}},{"Process":{"Description":"J-Pilot is a desktop organizer application for the palm pilot and other Palm OS devices. It is similar in functionality to the one that 3Com\/Palm distributes.","Process Name":"jpilot","Link":"https:\/\/linux.die.net\/man\/1\/jpilot"}},{"Process":{"Description":null,"Process Name":"jpilot-dial","Link":"https:\/\/linux.die.net\/man\/1\/jpilot-dial"}},{"Process":{"Description":"Dump jpilot databases.","Process Name":"jpilot-dump","Link":"https:\/\/linux.die.net\/man\/1\/jpilot-dump"}},{"Process":{"Description":null,"Process Name":"jpilot-sync","Link":"https:\/\/linux.die.net\/man\/1\/jpilot-sync"}},{"Process":{"Description":"The jps tool lists the instrumented HotSpot Java Virtual Machines (JVMs) on the target system. The tool is limited to reporting information on JVMs for which it has the access permissions. If jps is run without specifying a hostid, it will look for instrumented JVMs on the local host. If started with a hostid, it will look for JVMs on the indicated host, using the specified protocol and port. A jstatd process is assumed to be running on the target host. The jps command will report the local VM identifier, or lvmid, for each instrumented JVM found on the target system. The lvmid is typically, but not necessarily, the operating system's process identifier for the JVM process. With no options, jps will list each Java application's lvmid followed by the short form of the application's class name or jar file name. The short form of the class name or JAR file name omits the class's package information or the JAR files path information. The jps command uses the java launcher to find the class name and arguments passed to the main method. If the target JVM is started with a custom launcher, the class name (or JAR file name) and the arguments to the main method will not be available. In this case, the jps command will output the string Unknown for the class name or JAR file name and for the arguments to the main method. The list of JVMs produced by the jps command may be limited by the permissions granted to the principal running the command. The command will only list the JVMs for which the principle has access rights as determined by operating system specific access control mechanisms. NOTE: This utility is unsupported and may not be available in future versions of the JDK. It is not currently available on Windows 98 and Windows ME platforms.","Process Name":"jps-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jps-java-1.6.0-openjdk"}},{"Process":{"Description":"The jps tool lists the instrumented HotSpot Java Virtual Machines (JVMs) on the target system. The tool is limited to reporting information on JVMs for which it has the access permissions. If jps is run without specifying a hostid, it will look for instrumented JVMs on the local host. If started with a hostid, it will look for JVMs on the indicated host, using the specified protocol and port. A jstatd process is assumed to be running on the target host. The jps command will report the local VM identifier, or lvmid, for each instrumented JVM found on the target system. The lvmid is typically, but not necessarily, the operating system's process identifier for the JVM process. With no options, jps will list each Java application's lvmid followed by the short form of the application's class name or jar file name. The short form of the class name or JAR file name omits the class's package information or the JAR files path information. The jps command uses the java launcher to find the class name and arguments passed to the main method. If the target JVM is started with a custom launcher, the class name (or JAR file name) and the arguments to the main method will not be available. In this case, the jps command will output the string Unknown for the class name or JAR file name and for the arguments to the main method. The list of JVMs produced by the jps command may be limited by the permissions granted to the principal running the command. The command will only list the JVMs for which the principle has access rights as determined by operating system specific access control mechanisms. NOTE: This utility is unsupported and may not be available in future versions of the JDK. It is not currently available on Windows 98 and Windows ME platforms.","Process Name":"jps-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jps-java-1.7.0-openjdk"}},{"Process":{"Description":null,"Process Name":"jrancid","Link":"https:\/\/linux.die.net\/man\/1\/jrancid"}},{"Process":{"Description":"jrunscript is a command line script shell. jrunscript supports both an interactive (read-eval-print) mode and a batch (-f option) mode of script execution. This is a scripting language independent shell. By default, JavaScript is the language used, but the -l option can be used to specify a different language. Through Java to scripting language communication, jrunscript supports \"exploratory programming\" style. NOTE: This tool is experimental and may not be available in future versions of the JDK.","Process Name":"jrunscript-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jrunscript-java-1.6.0-openjdk"}},{"Process":{"Description":"jrunscript is a command line script shell. jrunscript supports both an interactive (read-eval-print) mode and a batch (-f option) mode of script execution. This is a scripting language independent shell. By default, JavaScript is the language used, but the -l option can be used to specify a different language. Through Java to scripting language communication, jrunscript supports \"exploratory programming\" style. NOTE: This tool is experimental and may not be available in future versions of the JDK.","Process Name":"jrunscript-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jrunscript-java-1.7.0-openjdk"}},{"Process":{"Description":"jsadebugd attaches to a Java process or core file and acts as a debug server. Remote clients such as jstack, jmap, and jinfo can attach to the server using Java Remote Method Invocation (RMI). Before starting jsadebugd, rmiregistry must be started with: rmiregistry -J-Xbootclasspath\/p:$JAVA_HOME\/lib\/sajdi.jar\n\n where $JAVA_HOME is the JDK installation directory. If rmiregistry was not started, jsadebugd will start an rmiregistry in a standard (1099) port internally. Debug server may be stopped by sending SIGINT (pressing Ctrl-C) to it. NOTE - This utility is unsupported and may or may not be available in future versions of the JDK. jsadebugd is not currently available on Windows platforms.","Process Name":"jsadebugd-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jsadebugd-java-1.6.0-openjdk"}},{"Process":{"Description":null,"Process Name":"jsadebugd-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jsadebugd-java-1.7.0-openjdk"}},{"Process":{"Description":"jsattach is used for attaching a serial line to a joystick device via a line dicipline. Exactly one of the following modes must be specified on the command line.","Process Name":"jsattach","Link":"https:\/\/linux.die.net\/man\/1\/jsattach"}},{"Process":{"Description":"jscal is a joystick calibration program for Linux joystick driver.","Process Name":"jscal","Link":"https:\/\/linux.die.net\/man\/1\/jscal"}},{"Process":{"Description":"","Process Name":"json2po","Link":"https:\/\/linux.die.net\/man\/1\/json2po"}},{"Process":{"Description":"json_xs converts between some input and output formats (one of them is JSON ). The default input format is \"json\" and the default output format is \"json-pretty\".","Process Name":"json_xs","Link":"https:\/\/linux.die.net\/man\/1\/json_xs"}},{"Process":{"Description":"jstack prints Java stack traces of Java threads for a given Java process or core file or a remote debug server. For each Java frame, the full class name, method name, 'bci' (byte code index) and line number, if available, are printed. With the -m option, jstack prints both Java and native frames of all threads along with the 'pc' (program counter). For each native frame, the closest native symbol to 'pc', if available, is printed. C++ mangled names are not demangled. To demangle C++ names, the output of this command may be piped to c++filt. If the given process is running on a 64-bit VM, you may need to specify the -J-d64 option, e.g.: jstack -J-d64 -m pid\n\n NOTE - This utility is unsupported and may or may not be available in future versions of the JDK. The only form of jstack that is available on Windows platforms is     jstack pid","Process Name":"jstack-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jstack-java-1.6.0-openjdk"}},{"Process":{"Description":"jstack prints Java stack traces of Java threads for a given Java process or core file or a remote debug server. For each Java frame, the full class name, method name, 'bci' (byte code index) and line number, if available, are printed. With the -m option, jstack prints both Java and native frames of all threads along with the 'pc' (program counter). For each native frame, the closest native symbol to 'pc', if available, is printed. C++ mangled names are not demangled. To demangle C++ names, the output of this command may be piped to c++filt. If the given process is running on a 64-bit VM, you may need to specify the -J-d64 option, e.g.: jstack -J-d64 -m pid\n\n NOTE - This utility is unsupported and may or may not be available in future versions of the JDK. In Windows Systems where dbgeng.dll is not present, 'Debugging Tools For Windows' needs to be installed to have these tools working. Also, PATH environment variable should contain the location of jvm.dll used by the target process or the location from which the Crash Dump file was produced. For example, set PATH=<jdk>\\jre\\bin\\client;%PATH%","Process Name":"jstack-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jstack-java-1.7.0-openjdk"}},{"Process":{"Description":"JOE is a powerful ASCII-text screen editor. It has a \"mode-less\" user interface which is similar to many user-friendly PC editors. Users of Micro-Pro's WordStar or Borland's \"Turbo\" languages will feel at home. JOE is a full featured UNIX screen-editor though, and has many features for editing programs and text. JOE also emulates several other editors. JSTAR is a close imitation of WordStar with many \"JOE\" extensions. JPICO is a close imitation of the Pine mailing system's PICO editor, but with many extensions and improvements. JMACS is a GNU-EMACS imitation. RJOE is a restricted version of JOE, which allows you to edit only the files specified on the command line. Although JOE is actually five different editors, it still requires only one executable, but one with five different names. The name of the editor with an \"rc\" appended gives the name of JOE's initialization file, which determines the personality of the editor. JOE is free software; you can distribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation. I have no plans for turning JOE into a commercial or share-ware product. JOE is available over the Internet from www.sourceforge.net\/projects\/joe-editor.","Process Name":"jstar","Link":"https:\/\/linux.die.net\/man\/1\/jstar"}},{"Process":{"Description":"The jstat tool displays performance statistics for an instrumented HotSpot Java virtual machine (JVM). The target JVM is identified by its virtual machine identifier, or vmid option described below. NOTE: This utility is unsupported and may not be available in future versions of the JDK. It is not currently available on Windows 98 and Windows ME. platforms. VIRTUAL MACHINE IDENTIFIER The syntax of the vmid string largely corresponds to the syntax of a URI: [protocol:][\/\/]lvmid[@hostname][:port][\/servername] protocol The communications protocol. If the protocol is omitted and a hostname is not specified, the default protocol is a platform specific optimized local protocol. If the protocol is omitted and a hostname is specified, then the default protocol is rmi. lvmid The local virtual machine identifier for the target JVM. The lvmid is a platform-specific value that uniquely identifies a JVM on a system. The lvmid is the only required component of a virtual machine identifier. The lvmid is typically, but not necessarily, the operating system's process identifier for the target JVM process. You can use the jps command to determine the lvmid. Also, you can determine lvmid on Unix platforms with the ps command, and on Windows with the Windows Task Manager. hostname A hostname or IP address indicating the target host. If hostname is omitted, then the target host is the local host. port The default port for communicating with the remote server. If the hostname is omitted or the protocol specifies an optimized, local protocol, then port is ignored. Otherwise, treatment of the port parameter is implementation specific. For the default rmi protocol, the port indicates the port number for the rmiregistry on the remote host. If port is omitted, and protocol indicates rmi, then the default rmiregistry port (1099) is used. servername The treatment of this parameter depends on implementation. For the optimized local protocol, this field is ignored. For the rmi protocol, it represents the name of the RMI remote object on the remote host.","Process Name":"jstat-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jstat-java-1.6.0-openjdk"}},{"Process":{"Description":"The jstat tool displays performance statistics for an instrumented HotSpot Java virtual machine (JVM). The target JVM is identified by its virtual machine identifier, or vmid option described below. NOTE: This utility is unsupported and may not be available in future versions of the JDK. It is not currently available on Windows 98 and Windows ME. platforms. VIRTUAL MACHINE IDENTIFIER The syntax of the vmid string largely corresponds to the syntax of a URI: [protocol:][\/\/]lvmid[@hostname][:port][\/servername] protocol The communications protocol. If the protocol is omitted and a hostname is not specified, the default protocol is a platform specific optimized local protocol. If the protocol is omitted and a hostname is specified, then the default protocol is rmi. lvmid The local virtual machine identifier for the target JVM. The lvmid is a platform-specific value that uniquely identifies a JVM on a system. The lvmid is the only required component of a virtual machine identifier. The lvmid is typically, but not necessarily, the operating system's process identifier for the target JVM process. You can use the jps(1) command to determine the lvmid. Also, you can determine lvmid on Unix platforms with the ps command, and on Windows with the Windows Task Manager. hostname A hostname or IP address indicating the target host. If hostname is omitted, then the target host is the local host. port The default port for communicating with the remote server. If the hostname is omitted or the protocol specifies an optimized, local protocol, then port is ignored. Otherwise, treatment of the port parameter is implementation specific. For the default rmi protocol, the port indicates the port number for the rmiregistry on the remote host. If port is omitted, and protocol indicates rmi, then the default rmiregistry port (1099) is used. servername The treatment of this parameter depends on implementation. For the optimized local protocol, this field is ignored. For the rmi protocol, it represents the name of the RMI remote object on the remote host.","Process Name":"jstat-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jstat-java-1.7.0-openjdk"}},{"Process":{"Description":"The jstatd tool is an RMI server application that monitors for the creation and termination of instrumented HotSpot Java virtual machines (JVMs) and provides a interface to allow remote monitoring tools to attach to JVMs running on the local host. The jstatd server requires the presence of an RMI registry on the local host. The jstatd server will attempt to attach to the RMI registry on the default port, or on the port indicated by the -p port option. If an RMI registry is not found, one will be created within the jstatd application bound to the port indicated by the -p port option or to the default RMI registry port if -p port is omitted. Creation of an internal RMI registry can be inhibited by specifying the -nr option. NOTE: This utility is unsupported and may or may not be available in future versions of the JDK. It is not currently available on the Windows 98 and Windows ME platforms.","Process Name":"jstatd-java-1.6.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jstatd-java-1.6.0-openjdk"}},{"Process":{"Description":"The jstatd tool is an RMI server application that monitors for the creation and termination of instrumented HotSpot Java virtual machines (JVMs) and provides a interface to allow remote monitoring tools to attach to JVMs running on the local host. The jstatd server requires the presence of an RMI registry on the local host. The jstatd server will attempt to attach to the RMI registry on the default port, or on the port indicated by the -p port option. If an RMI registry is not found, one will be created within the jstatd application bound to the port indicated by the -p port option or to the default RMI registry port if -p port is omitted. Creation of an internal RMI registry can be inhibited by specifying the -nr option. NOTE: This utility is unsupported and may or may not be available in future versions of the JDK. It is not currently available on the Windows 98 and Windows ME platforms.","Process Name":"jstatd-java-1.7.0-openjdk","Link":"https:\/\/linux.die.net\/man\/1\/jstatd-java-1.7.0-openjdk"}},{"Process":{"Description":"jstest can be used to test all the features of the Linux joystick API, including non-blocking and select(2) access, as well as version 0.x compatibility mode. It is also intended to serve as an example implementation for those who wish to learn how to write their own joystick using applications.","Process Name":"jstest","Link":"https:\/\/linux.die.net\/man\/1\/jstest"}},{"Process":{"Description":"JSV is an abbreviation for Job Submission Verifier. A JSV is a script or binary that can be used to verify, modify or reject a job during the time of job submission. JSVs will be triggered by submit clients like qsub, qrsh, qsh and qmon on submit hosts (Client JSV) or they verify incoming jobs on the master host (Server JSV) or both.","Process Name":"jsv","Link":"https:\/\/linux.die.net\/man\/1\/jsv"}},{"Process":{"Description":"jsvc executes classfile that implements a Daemon interface.","Process Name":"jsvc","Link":"https:\/\/linux.die.net\/man\/1\/jsvc"}},{"Process":{"Description":null,"Process Name":"jtag","Link":"https:\/\/linux.die.net\/man\/1\/jtag"}},{"Process":{"Description":"Draws a juggling stick-man.","Process Name":"juggle","Link":"https:\/\/linux.die.net\/man\/1\/juggle"}},{"Process":{"Description":null,"Process Name":"julia","Link":"https:\/\/linux.die.net\/man\/1\/julia"}},{"Process":{"Description":"Jumpshots are graphical tools for understanding the performance of parallel programs. They are evolved from upshot and are written in Java. There are 2 versions of Jumpshots, Jumpshot-2 and Jumpshot-3 , distributed with MPE. Jumpshot-2 interprets CLOG tracefiles and Jumpshot-3 interprets SLOG tracefiles which is capable of handle big tracefiles (in GB range).","Process Name":"jumpshots","Link":"https:\/\/linux.die.net\/man\/1\/jumpshots"}},{"Process":{"Description":null,"Process Name":"jura","Link":"https:\/\/linux.die.net\/man\/1\/jura"}},{"Process":{"Description":"juyin-learn displays Chinese characters' phonations in clipboard.","Process Name":"juyin-learn","Link":"https:\/\/linux.die.net\/man\/1\/juyin-learn"}},{"Process":{"Description":"jv-convert is a utility included with \"libgcj\" which converts a file from one encoding to another. It is similar to the Unix iconv utility. The encodings supported by jv-convert are platform-dependent. Currently there is no way to get a list of all supported encodings.","Process Name":"jv-convert","Link":"https:\/\/linux.die.net\/man\/1\/jv-convert"}},{"Process":{"Description":"The \"jv-scan\" program can be used to print information about a Java source file (.java file).","Process Name":"jv-scan","Link":"https:\/\/linux.die.net\/man\/1\/jv-scan"}},{"Process":{"Description":"The jw shell script allows to convert a DocBook file (or some other SGML-based format) to other formats (including HTML, RTF, PS and PDF) with an easy-to-understand syntax. It hides most of Jade's or OpenJade complexity and adds comfortable features. Other scripts like docbook2html, docbook2rtf or docbook2ps provide different ways of calling jw that might be easier to remember. For the moment, jw does not handle XML, but only SGML. This utility assumes that several other components are installed. The list includes: the ISO character entities for SGML James Clark's DSSSL engine, jade, or an equivalent parser like OpenJade the DocBook DTD from the OASIS consortium Norman Walsh's DocBook modular style sheets (or some other set of DSSSL style sheets) Sebastian Rahtz's jadetex set of TeX macros for jade (for backends intended to \"printing\" formats like PDF, RTF or PostScript) A perl interpreter (for backends that use perl) SGMLSpm from CPAN (for backends that use sgmls) Lynx HTML browser (for the txt backend) The jw script is basically called like this: jw mydoc.sgml where mydoc.sgml is a SGML file. The command line above uses default options: it converts from DocBook (the default frontend) to HTML (the default backend), does not put the result in a subdirectory (unless specified otherwise in the style sheets), etc. In this example, the \"mydoc\" file name as well as the \".sgml\" extension can be replaced by anything else. Current extensions for SGML DocBook files include \".sgml\", \".sgm\", \".docbook\", and \".db\". The processed file mydoc.sgml can be in any other directory than the current one. Here we have chosen to generate HTML output. In fact we can use any of the backends stored in the backends\/ subdirectory of the DocBook-utils distribution directory (usually \/usr\/share\/sgml\/docbook\/utils-0.6.14). Similarly, you can use any frontend defined in the frontends\/ subdirectory to convert from another input format. This sample command creates one or many HTML files with arbitrary file names in the current directory. This default behavior can be changed through command line options and\/or customization style sheets.","Process Name":"jw","Link":"https:\/\/linux.die.net\/man\/1\/jw"}},{"Process":{"Description":"jwhois searches Whois servers for the object on the command line. The host to query is taken from a global configuration file, a configuration file specified on the command line, or selected directly on the command line.","Process Name":"jwhois","Link":"https:\/\/linux.die.net\/man\/1\/jwhois"}},{"Process":{"Description":"JWM is a window manager for the X11 Window System.","Process Name":"jwm","Link":"https:\/\/linux.die.net\/man\/1\/jwm"}}]
[{"Process":{"Description":"DC_CTX_new() allocates and initialises a DC_CTX structure with an address for sending session caching operation requests to, and flags controlling the behaviour of the DC_CTX object. The address specified by target should be compatible with the syntax defined by the libnal API , see the \" NOTES \" section below. The flags parameter can be zero to indicate that each cache operation should create and destroy a temporary connection, otherwise a bitmask combining one or more of the following flags; #define DC_CTX_FLAG_PERSISTENT           (unsigned int)0x0001\n#define DC_CTX_FLAG_PERSISTENT_PIDCHECK  (unsigned int)0x0002\n#define DC_CTX_FLAG_PERSISTENT_RETRY     (unsigned int)0x0004\n#define DC_CTX_FLAG_PERSISTENT_LATE      (unsigned int)0x0008 DC_CTX_free() frees the ctx object. DC_CTX_add_session() attempts to add session data to the cache. id_data and id_len define the unique session ID corresponding to the session data - this is the ID used in DC_CTX_get_session() or DC_CTX_remove_session() to refer to the session being added, and the ''add'' operation will fail if there is already a session with a matching ID in the cache. sess_data and sess_len define the session data itself to be stored in the cache. timeout_msecs specifies the expiry period for the session - if this period of time passes without the corresponding session being explicitly removed nor scrolled out of the cache because of over-filling, then the cache server will remove the session from the cache anyway. DC_CTX_remove_session() provides a session ID with id_data and id_len and requests that the corresponding session be removed from the cache. DC_CTX_get_session() provides a session ID with id_data and id_len and requests that the corresponding session data be retrieved from the cache. result_storage and result_size specify a storage area for the retrieved session data, and result_used points to a variable that will be set to the length of the retrieved session data. Even if DC_CTX_get_session() returns successfully, the caller should check the value of result_used - if it is larger than result_size then the requested session data was too big for the provided storage area and only partial data will have been returned. In this case, the caller should immediately call DC_CTX_reget_session(). DC_CTX_reget_session() is similar to DC_CTX_get_session() except that it does not perform any network operations at all. It is designed to return session data that had previously been retrieved by DC_CTX_get_session(), so that a larger storage area can be provided if the one first provided to DC_CTX_get_session() was too small. This function will fail if the last operation on ctx was not DC_CTX_get_session() with an exact match for id_data and id_len. DC_CTX_has_session() is similar to DC_CTX_get_session() except that it does not ask for session data to be returned, merely to know whether the session is in the cache or not. This should be used by any application that already has a copy of the required session but merely wishes to verify that it hasn't already been explicitly invalidated. As distcache allows parallel use of a single cache from multiple clients across potentially multiple machines, it is a security flaw for any client (thread, process, or machine) to implement local session caching and using its sessions whenever there is a cache-hit. If the session was used and for any reason required invalidation (eg. renegotiation, data corruption detected, etc) then another client should not use a locally cached copy of the session without first verifying with the shared cache that the session is still OK . This function should be used in such cases as it provides the same check as DC_CTX_get_session() but with less network overhead.","Process Name":"dc_ctx_new","Link":"https:\/\/linux.die.net\/man\/2\/dc_ctx_new"}},{"Process":{"Description":null,"Process Name":"dc_plug_new","Link":"https:\/\/linux.die.net\/man\/2\/dc_plug_new"}},{"Process":{"Description":null,"Process Name":"dc_plug_read","Link":"https:\/\/linux.die.net\/man\/2\/dc_plug_read"}},{"Process":{"Description":null,"Process Name":"dc_server_new","Link":"https:\/\/linux.die.net\/man\/2\/dc_server_new"}},{"Process":{"Description":null,"Process Name":"delete_module","Link":"https:\/\/linux.die.net\/man\/2\/delete_module"}},{"Process":{"Description":null,"Process Name":"drecv","Link":"https:\/\/linux.die.net\/man\/2\/drecv"}},{"Process":{"Description":"These datalink functions pass a network message from one process to another and are the basis for all forms of LAM network communication. Although they can be invoked directly, they are most often called by the network and transport functions. The datalink functions do not supply message routing, buffering or packetization. The user supplies the event of the forwarding process and the message length is restricted to MAXNMSGLEN, defined in <net.h>. dsend() and drecv() are typically used to send messages to, or receive messages from, nearest neighbour nodes (see \"Typical Usage\"). dtry_send() and dtry_recv() never cause the calling process to block. The message is either immediately transferred, or an error is immediately returned, indicating that the process would have blocked. Network Message Structure All of the functions accept a pointer to a message structure which is an extension of the local level message structure used by ksend(2) and krecv(2). The network message structure is defined in <net.h> as: struct nmsg { int nh_dl_event; int nh_dl_link; int nh_node; int nh_event; int nh_type; int nh_length; int nh_flags; int nh_data[NHDSIZE]; char *nh_msg; }; The usage of each field in the network message structure is described below. nh_dl_event This field is used by dsend() to synchronize the sending process and a) a forwarding process such as a link output process, or b) a local receiving process. In the first case, the synchronization is between nh_dl_event and the published event of the forwarding process. The forwarding event is returned by getroute(2). In the second case, the synchronization is between nh_dl_event and the local receiver's nh_event field. The nh_dl_event field is not used by drecv(). The nh_dl_event field remains unchanged after calling dsend() or drecv(). nh_dl_link If nh_dl_event refers to a link output process, a specific link number must be given in the nh_dl_link field. Link output processes may handle multiple links. This field is not used by drecv(). The nh_dl_link field remains unchanged after calling dsend() or drecv(). nh_node This field is used by dsend() to identify the remote node running the intended receiver. Typically, the destination node is an immediate neighbour of the local node. The nh_node field is not used by drecv(). A receiving process thus cannot directly specify the source node of a message. Instead, receiving processes are \"matched\" to messages by one or both of nh_event and nh_type. The nh_node field is never altered. nh_event An event is an arbitrary positive integer used by the LAM daemon to synchronize processes within a node. Synchronization occurs when two events are equal. In a datalink transfer, nh_dl_event in the sender equals nh_event in the local receiver. When the local receiver is a forwarding process, the message begins a journey through the network system. Much more than one simple datalink transfer is taking place and the sender must give more information beyond nh_dl_event in the nh_node and nh_event fields. The message may be transmitted through a physical communication link to a neighbour node. On the destination remote node, the nh_event given by the original sender is copied to nh_dl_event and another typical datalink transfer occurs between a system process and the ultimate intended receiver calling drecv(). Thus, the sender calling dsend() must set nh_event to the same value as the intended receiver calling drecv(). If the datalink functions present too much complexity, try nsend(2) and nrecv(2). The nh_event field is never altered. nh_type This field further filters messages that match on event. A message will be passed only if the nh_type fields of the sender and receiver processes have at least one bit set in an identical position. In other words, the bitwise logical AND of the type fields specified by the two parties must not equal zero. A zero value matches any other value of nh_type. The dsend() function compares nh_dl_event and nh_event to decided if the receiver is a forwarding process. If they are equal, nh_type is used as described above. Otherwise, usage of nh_type is deferred until the message arrives at the destination node for synchronization with the ultimate intended receiver and special type values are immediately used to codify the message and control synchronization with the forwarding process. If nh_event is negative, a type signifying a system message is used, otherwise the type identifies a user message. Application programs should not directly specify negative values for nh_event. If the datalink functions present too much complexity, try nsend(2) and nrecv(2). The nh_type field remains unchanged after calling dsend(), but is set to the sender's nh_type after calling drecv(). nh_length This field holds the length (in bytes) of the message to be sent. If the sender and the receiver specify different lengths, the lesser amount will be transferred. The maximum length of messages transferred with dsend() and drecv() is MAXNMSGLEN, defined in <net.h> and usually set to 8192 bytes. Forwarding processes in the LAM network subsystem always use MAXNMSGLEN. The nh_length field remains unchanged after calling dsend(), but is set to the minimum of the sender's and receiver's lengths after calling drecv(). nh_flags This field is normally set to 0. Flags used to ensure that the data representation is correct for the receiving node are discussed under \"Data Representation\". The nh_flags field is never altered. nh_data This field is a convenient data pouch within the network message descriptor. Its array size is NHDSIZE words, which is defined in <net.h> and is currently set to 8. It can be used for sending short messages (in which case nh_length is set to 0) or for appending control information to the message body. After calling drecv() the nh_data field is overwritten with the sender's values of the same field. The sender's nh_data will not change. nh_msg This field holds the address of the first byte of data to be sent or received. The data must be stored contiguously in memory. The nh_msg field is never altered. Data Representation On nodes of different architectures, data may have different representations. For example, integers may be stored with the most significant byte first in memory (big-endian) or with the most significant byte last in memory (little-endian). Also, the representation of floating point numbers may conform to the IEEE standard or may follow a vendor specific format. All fields in the network message structure, except the data referenced by nh_msg, are automatically converted if passed to a node with different data representation. The nh_data field is assumed to hold all integers. The nh_flags field of the message structure can be set to the following data representation flags. Each flag assumes a data type, and will make the appropriate change in the data representation of the given field. They will have no effect if data conversion is not needed. DINT4DATA nh_data holds 8 32-bit integers (default). DFLT4DATA nh_data holds 8 single 32-bit real numbers. DFLT8DATA nh_data holds 4 64-bit real numbers. DRAWDATA nh_data representation will not be changed. DINT4MSG nh_msg points to 32-bit integers. DFLT4MSG nh_msg points to 32-bit real numbers. DFLT8MSG nh_msg points to 64-bit real numbers. DRAWMSG nh_msg representation will not be changed (default). If nh_data or nh_msg contains a mixture of data types, the user will have to change the representation using the functions ltoti4(3), ttoli4(3), etc. Typical Usage The typical usage of the datalink functions is for nearest neighbour message passing, when the user wishes to avoid the expense of automatic message routing (as provided by nsend(2)) and other network level overheads. To synchronize the sender and receiver, the sender must set nh_node to the destination neighbour's node ID, nh_dl_event to the link process event connecting the neighbour node, nh_dl_link to the specific link number and nh_event to its counterpart in the receiver. Blocking A process calling drecv() blocks until the message sent by the process calling dsend() entirely arrives. A process calling dsend() blocks only until its message is picked up by a) a local receiver calling drecv() or b) the local forwarding process identified by nh_dl_event. The only thing that is guaranteed by a successful return from dsend() is that the message has entirely left the calling process. The loose blocking behaviour of dsend() introduces a fundamental danger of LAM message passing: a sender can transmit a message that may never be received due to programming error or deadlock. This message will never be dropped or timed out. Some LAM process will always be stuck with it, waiting for a synchronizing drecv() that may never happen. If the process is a link proprietor, the link could become plugged and useless. A link input process may hold one message. A link output process may hold several messages, depending on its internal implementation.","Process Name":"dsend","Link":"https:\/\/linux.die.net\/man\/2\/dsend"}},{"Process":{"Description":null,"Process Name":"dup","Link":"https:\/\/linux.die.net\/man\/2\/dup"}},{"Process":{"Description":null,"Process Name":"dup2","Link":"https:\/\/linux.die.net\/man\/2\/dup2"}},{"Process":{"Description":"These system calls create a copy of the file descriptor oldfd. dup() uses the lowest-numbered unused descriptor for the new descriptor. dup2() makes newfd be the copy of oldfd, closing newfd first if necessary, but note the following: * If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed. * If oldfd is a valid file descriptor, and newfd has the same value as oldfd, then dup2() does nothing, and returns newfd. After a successful return from one of these system calls, the old and new file descriptors may be used interchangeably. They refer to the same open file description (see open(2)) and thus share file offset and file status flags; for example, if the file offset is modified by using lseek(2) on one of the descriptors, the offset is also changed for the other. The two descriptors do not share file descriptor flags (the close-on-exec flag). The close-on-exec flag (FD_CLOEXEC; see fcntl(2)) for the duplicate descriptor is off. dup3() is the same as dup2(), except that: * The caller can force the close-on-exec flag to be set for the new file descriptor by specifying O_CLOEXEC in flags. See the description of the same flag in open(2) for reasons why this may be useful. * If oldfd equals newfd, then dup3() fails with the error EINVAL.","Process Name":"dup3","Link":"https:\/\/linux.die.net\/man\/2\/dup3"}}]
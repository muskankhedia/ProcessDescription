[{"Process":{"Description":"The faccessat() system call operates in exactly the same way as access(2), except for the differences described in this manual page. If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done by access(2) for a relative pathname). If pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the current working directory of the calling process (like access(2)). If pathname is absolute, then dirfd is ignored. flags is constructed by ORing together zero or more of the following values: AT_EACCESS Perform access checks using the effective user and group IDs. By default, faccessat() uses the real IDs (like access(2)). AT_SYMLINK_NOFOLLOW If pathname is a symbolic link, do not dereference it: instead return information about the link itself.","Process Name":"faccessat","Link":"https:\/\/linux.die.net\/man\/2\/faccessat"}},{"Process":{"Description":null,"Process Name":"fadvise","Link":"https:\/\/linux.die.net\/man\/2\/fadvise"}},{"Process":{"Description":"Programs can use posix_fadvise() to announce an intention to access file data in a specific pattern in the future, thus allowing the kernel to perform appropriate optimizations. The advice applies to a (not necessarily existent) region starting at offset and extending for len bytes (or until the end of the file if len is 0) within the file referred to by fd. The advice is not binding; it merely constitutes an expectation on behalf of the application. Permissible values for advice include: POSIX_FADV_NORMAL Indicates that the application has no advice to give about its access pattern for the specified data. If no advice is given for an open file, this is the default assumption. POSIX_FADV_SEQUENTIAL The application expects to access the specified data sequentially (with lower offsets read before higher ones). POSIX_FADV_RANDOM The specified data will be accessed in random order. POSIX_FADV_NOREUSE The specified data will be accessed only once. POSIX_FADV_WILLNEED The specified data will be accessed in the near future. POSIX_FADV_DONTNEED The specified data will not be accessed in the near future.","Process Name":"fadvise64","Link":"https:\/\/linux.die.net\/man\/2\/fadvise64"}},{"Process":{"Description":null,"Process Name":"fadvise64_64","Link":"https:\/\/linux.die.net\/man\/2\/fadvise64_64"}},{"Process":{"Description":"This is a nonportable, Linux-specific system call. For the portable, POSIX.1-specified method of ensuring that space is allocated for a file, see posix_fallocate(3). fallocate() allows the caller to directly manipulate the allocated disk space for the file referred to by fd for the byte range starting at offset and continuing for len bytes. The mode argument determines the operation to be performed on the given range. Details of the supported operations are given in the subsections below. Allocating disk space The default operation (i.e., mode is zero) of fallocate() allocates and initializes to zero the disk space within the range specified by offset and len. The file size (as reported by stat(2)) will be changed if offset+ len is greater than the file size. This default behavior closely resembles the behavior of the posix_fallocate(3) library function, and is intended as a method of optimally implementing that function. After a successful call, subsequent writes into the range specified by offset and len are guaranteed not to fail because of lack of disk space. If the FALLOC_FL_KEEP_SIZE flag is specified in mode, the behavior of the call is similar, but the file size will not be changed even if offset+len is greater than the file size. Preallocating zeroed blocks beyond the end of the file in this manner is useful for optimizing append workloads. Because allocation is done in block size chunks, fallocate() may allocate a larger range of disk space than was specified. Deallocating file space Specifying the FALLOC_FL_PUNCH_HOLE flag (available since Linux 2.6.38) in mode deallocates space (i.e., creates a hole) in the byte range starting at offset and continuing for len bytes. Within the specified range, partial file system blocks are zeroed, and whole file system blocks are removed from the file. After a successful call, subsequent reads from this range will return zeroes. The FALLOC_FL_PUNCH_HOLE flag must be ORed with FALLOC_FL_KEEP_SIZE in mode; in other words, even when punching off the end of the file, the file size (as reported by stat(2)) does not change. Not all file systems support FALLOC_FL_PUNCH_HOLE; if a file system doesn't support the operation, an error is returned.","Process Name":"fallocate","Link":"https:\/\/linux.die.net\/man\/2\/fallocate"}},{"Process":{"Description":null,"Process Name":"fattach","Link":"https:\/\/linux.die.net\/man\/2\/fattach"}},{"Process":{"Description":null,"Process Name":"fattch","Link":"https:\/\/linux.die.net\/man\/2\/fattch"}},{"Process":{"Description":null,"Process Name":"fchdir","Link":"https:\/\/linux.die.net\/man\/2\/fchdir"}},{"Process":{"Description":null,"Process Name":"fchmod","Link":"https:\/\/linux.die.net\/man\/2\/fchmod"}},{"Process":{"Description":null,"Process Name":"fchmodat","Link":"https:\/\/linux.die.net\/man\/2\/fchmodat"}},{"Process":{"Description":"These system calls change the owner and group of a file. They differ only in how the file is specified: * chown() changes the ownership of the file specified by path, which is dereferenced if it is a symbolic link. * fchown() changes the ownership of the file referred to by the open file descriptor fd. * lchown() is like chown(), but does not dereference symbolic links. Only a privileged process (Linux: one with the CAP_CHOWN capability) may change the owner of a file. The owner of a file may change the group of the file to any group of which that owner is a member. A privileged process (Linux: with CAP_CHOWN) may change the group arbitrarily. If the owner or group is specified as -1, then that ID is not changed. When the owner or group of an executable file are changed by an unprivileged user the S_ISUID and S_ISGID mode bits are cleared. POSIX does not specify whether this also should happen when root does the chown(); the Linux behavior depends on the kernel version. In case of a non-group-executable file (i.e., one for which the S_IXGRP bit is not set) the S_ISGID bit indicates mandatory locking, and is not cleared by a chown().","Process Name":"fchown","Link":"https:\/\/linux.die.net\/man\/2\/fchown"}},{"Process":{"Description":null,"Process Name":"fchown32","Link":"https:\/\/linux.die.net\/man\/2\/fchown32"}},{"Process":{"Description":"The fchownat() system call operates in exactly the same way as chown(2), except for the differences described in this manual page. If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dirfd (rather than relative to the current working directory of the calling process, as is done by chown(2) for a relative pathname). If pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the current working directory of the calling process (like chown(2)). If pathname is absolute, then dirfd is ignored. flags can either be 0, or include the following flag: AT_SYMLINK_NOFOLLOW If pathname is a symbolic link, do not dereference it: instead operate on the link itself, like lchown(2). (By default, fchownat() dereferences symbolic links, like chown(2).)","Process Name":"fchownat","Link":"https:\/\/linux.die.net\/man\/2\/fchownat"}},{"Process":{"Description":null,"Process Name":"fcntl","Link":"https:\/\/linux.die.net\/man\/2\/fcntl"}},{"Process":{"Description":"fcntl() performs one of the operations described below on the open file descriptor fd. The operation is determined by cmd. fcntl() can take an optional third argument. Whether or not this argument is required is determined by cmd. The required argument type is indicated in parentheses after each cmd name (in most cases, the required type is int, and we identify the argument using the name arg), or void is specified if the argument is not required. Duplicating a file descriptor F_DUPFD ( int) Find the lowest numbered available file descriptor greater than or equal to arg and make it be a copy of fd. This is different from dup2(2), which uses exactly the descriptor specified. On success, the new descriptor is returned. See dup(2) for further details. F_DUPFD_CLOEXEC ( int; since Linux 2.6.24) As for F_DUPFD, but additionally set the close-on-exec flag for the duplicate descriptor. Specifying this flag permits a program to avoid an additional fcntl() F_SETFD operation to set the FD_CLOEXEC flag. For an explanation of why this flag is useful, see the description of O_CLOEXEC in open(2). File descriptor flags The following commands manipulate the flags associated with a file descriptor. Currently, only one such flag is defined: FD_CLOEXEC, the close-on-exec flag. If the FD_CLOEXEC bit is 0, the file descriptor will remain open across an execve(2), otherwise it will be closed. F_GETFD ( void) Read the file descriptor flags; arg is ignored. F_SETFD ( int) Set the file descriptor flags to the value specified by arg. File status flags Each open file description has certain associated status flags, initialized by open(2) and possibly modified by fcntl(). Duplicated file descriptors (made with dup(2), fcntl(F_DUPFD), fork(2), etc.) refer to the same open file description, and thus share the same file status flags. The file status flags and their semantics are described in open(2). F_GETFL ( void) Get the file access mode and the file status flags; arg is ignored. F_SETFL ( int) Set the file status flags to the value specified by arg. File access mode ( O_RDONLY, O_WRONLY, O_RDWR) and file creation flags (i.e., O_CREAT, O_EXCL, O_NOCTTY, O_TRUNC) in arg are ignored. On Linux this command can change only the O_APPEND, O_ASYNC, O_DIRECT, O_NOATIME, and O_NONBLOCK flags. Advisory locking F_GETLK, F_SETLK and F_SETLKW are used to acquire, release, and test for the existence of record locks (also known as file-segment or file-region locks). The third argument, lock, is a pointer to a structure that has at least the following fields (in unspecified order). struct flock {\n    ...\n    short l_type;    \/* Type of lock: F_RDLCK,\n                        F_WRLCK, F_UNLCK *\/\n    short l_whence;  \/* How to interpret l_start:\n                        SEEK_SET, SEEK_CUR, SEEK_END *\/\n    off_t l_start;   \/* Starting offset for lock *\/\n    off_t l_len;     \/* Number of bytes to lock *\/\n    pid_t l_pid;     \/* PID of process blocking our lock\n                        (F_GETLK only) *\/\n    ...\n}; The l_whence, l_start, and l_len fields of this structure specify the range of bytes we wish to lock. Bytes past the end of the file may be locked, but not bytes before the start of the file. l_start is the starting offset for the lock, and is interpreted relative to either: the start of the file (if l_whence is SEEK_SET); the current file offset (if l_whence is SEEK_CUR); or the end of the file (if l_whence is SEEK_END). In the final two cases, l_start can be a negative number provided the offset does not lie before the start of the file. l_len specifies the number of bytes to be locked. If l_len is positive, then the range to be locked covers bytes l_start up to and including l_start+l_len-1. Specifying 0 for l_len has the special meaning: lock all bytes starting at the location specified by l_whence and l_start through to the end of file, no matter how large the file grows. POSIX.1-2001 allows (but does not require) an implementation to support a negative l_len value; if l_len is negative, the interval described by lock covers bytes l_start+l_len up to and including l_start-1. This is supported by Linux since kernel versions 2.4.21 and 2.5.49. The l_type field can be used to place a read (F_RDLCK) or a write (F_WRLCK) lock on a file. Any number of processes may hold a read lock (shared lock) on a file region, but only one process may hold a write lock (exclusive lock). An exclusive lock excludes all other locks, both shared and exclusive. A single process can hold only one type of lock on a file region; if a new lock is applied to an already-locked region, then the existing lock is converted to the new lock type. (Such conversions may involve splitting, shrinking, or coalescing with an existing lock if the byte range specified by the new lock does not precisely coincide with the range of the existing lock.) F_SETLK ( struct flock *) Acquire a lock (when l_type is F_RDLCK or F_WRLCK) or release a lock (when l_type is F_UNLCK) on the bytes specified by the l_whence, l_start, and l_len fields of lock. If a conflicting lock is held by another process, this call returns -1 and sets errno to EACCES or EAGAIN. F_SETLKW ( struct flock *) As for F_SETLK, but if a conflicting lock is held on the file, then wait for that lock to be released. If a signal is caught while waiting, then the call is interrupted and (after the signal handler has returned) returns immediately (with return value -1 and errno set to EINTR; see signal(7)). F_GETLK ( struct flock *) On input to this call, lock describes a lock we would like to place on the file. If the lock could be placed, fcntl() does not actually place it, but returns F_UNLCK in the l_type field of lock and leaves the other fields of the structure unchanged. If one or more incompatible locks would prevent this lock being placed, then fcntl() returns details about one of these locks in the l_type, l_whence, l_start, and l_len fields of lock and sets l_pid to be the PID of the process holding that lock. In order to place a read lock, fd must be open for reading. In order to place a write lock, fd must be open for writing. To place both types of lock, open a file read-write. As well as being removed by an explicit F_UNLCK, record locks are automatically released when the process terminates or if it closes any file descriptor referring to a file on which locks are held. This is bad: it means that a process can lose the locks on a file like \/etc\/passwd or \/etc\/mtab when for some reason a library function decides to open, read and close it. Record locks are not inherited by a child created via fork(2), but are preserved across an execve(2). Because of the buffering performed by the stdio(3) library, the use of record locking with routines in that package should be avoided; use read(2) and write(2) instead. Mandatory locking (Non-POSIX.) The above record locks may be either advisory or mandatory, and are advisory by default. Advisory locks are not enforced and are useful only between cooperating processes. Mandatory locks are enforced for all processes. If a process tries to perform an incompatible access (e.g., read(2) or write(2)) on a file region that has an incompatible mandatory lock, then the result depends upon whether the O_NONBLOCK flag is enabled for its open file description. If the O_NONBLOCK flag is not enabled, then system call is blocked until the lock is removed or converted to a mode that is compatible with the access. If the O_NONBLOCK flag is enabled, then the system call fails with the error EAGAIN. To make use of mandatory locks, mandatory locking must be enabled both on the file system that contains the file to be locked, and on the file itself. Mandatory locking is enabled on a file system using the \"-o mand\" option to mount(8), or the MS_MANDLOCK flag for mount(2). Mandatory locking is enabled on a file by disabling group execute permission on the file and enabling the set-group-ID permission bit (see chmod(1) and chmod(2)). The Linux implementation of mandatory locking is unreliable. See BUGS below. Managing signals F_GETOWN, F_SETOWN, F_GETOWN_EX, F_SETOWN_EX, F_GETSIG and F_SETSIG are used to manage I\/O availability signals: F_GETOWN ( void) Return (as the function result) the process ID or process group currently receiving SIGIO and SIGURG signals for events on file descriptor fd. Process IDs are returned as positive values; process group IDs are returned as negative values (but see BUGS below). arg is ignored. F_SETOWN ( int) Set the process ID or process group ID that will receive SIGIO and SIGURG signals for events on file descriptor fd to the ID given in arg. A process ID is specified as a positive value; a process group ID is specified as a negative value. Most commonly, the calling process specifies itself as the owner (that is, arg is specified as getpid(2)). If you set the O_ASYNC status flag on a file descriptor by using the F_SETFL command of fcntl(), a SIGIO signal is sent whenever input or output becomes possible on that file descriptor. F_SETSIG can be used to obtain delivery of a signal other than SIGIO. If this permission check fails, then the signal is silently discarded. Sending a signal to the owner process (group) specified by F_SETOWN is subject to the same permissions checks as are described for kill(2), where the sending process is the one that employs F_SETOWN (but see BUGS below). If the file descriptor fd refers to a socket, F_SETOWN also selects the recipient of SIGURG signals that are delivered when out-of-band data arrives on that socket. (SIGURG is sent in any situation where select(2) would report the socket as having an \"exceptional condition\".) The following was true in 2.6.x kernels up to and including kernel 2.6.11: If a nonzero value is given to F_SETSIG in a multithreaded process running with a threading library that supports thread groups (e.g., NPTL), then a positive value given to F_SETOWN has a different meaning: instead of being a process ID identifying a whole process, it is a thread ID identifying a specific thread within a process. Consequently, it may be necessary to pass F_SETOWN the result of gettid(2) instead of getpid(2) to get sensible results when F_SETSIG is used. (In current Linux threading implementations, a main thread's thread ID is the same as its process ID. This means that a single-threaded program can equally use gettid(2) or getpid(2) in this scenario.) Note, however, that the statements in this paragraph do not apply to the SIGURG signal generated for out-of-band data on a socket: this signal is always sent to either a process or a process group, depending on the value given to F_SETOWN. The above behavior was accidentally dropped in Linux 2.6.12, and won't be restored. From Linux 2.6.32 onward, use F_SETOWN_EX to target SIGIO and SIGURG signals at a particular thread. F_GETOWN_EX (struct f_owner_ex *) (since Linux 2.6.32) Return the current file descriptor owner settings as defined by a previous F_SETOWN_EX operation. The information is returned in the structure pointed to by arg, which has the following form: struct f_owner_ex {\n    int   type;\n    pid_t pid;\n}; The type field will have one of the values F_OWNER_TID, F_OWNER_PID, or F_OWNER_PGRP. The pid field is a positive integer representing a thread ID, process ID, or process group ID. See F_SETOWN_EX for more details. F_SETOWN_EX (struct f_owner_ex *) (since Linux 2.6.32) This operation performs a similar task to F_SETOWN. It allows the caller to direct I\/O availability signals to a specific thread, process, or process group. The caller specifies the target of signals via arg, which is a pointer to a f_owner_ex structure. The type field has one of the following values, which define how pid is interpreted: F_OWNER_TID Send the signal to the thread whose thread ID (the value returned by a call to clone(2) or gettid(2)) is specified in pid. F_OWNER_PID Send the signal to the process whose ID is specified in pid. F_OWNER_PGRP Send the signal to the process group whose ID is specified in pid. (Note that, unlike with F_SETOWN, a process group ID is specified as a positive value here.) F_GETSIG ( void) Return (as the function result) the signal sent when input or output becomes possible. A value of zero means SIGIO is sent. Any other value (including SIGIO) is the signal sent instead, and in this case additional info is available to the signal handler if installed with SA_SIGINFO. arg is ignored. F_SETSIG ( int) Set the signal sent when input or output becomes possible to the value given in arg. A value of zero means to send the default SIGIO signal. Any other value (including SIGIO) is the signal to send instead, and in this case additional info is available to the signal handler if installed with SA_SIGINFO. By using F_SETSIG with a nonzero value, and setting SA_SIGINFO for the signal handler (see sigaction(2)), extra information about I\/O events is passed to the handler in a siginfo_t structure. If the si_code field indicates the source is SI_SIGIO, the si_fd field gives the file descriptor associated with the event. Otherwise, there is no indication which file descriptors are pending, and you should use the usual mechanisms (select(2), poll(2), read(2) with O_NONBLOCK set etc.) to determine which file descriptors are available for I\/O. By selecting a real time signal (value >= SIGRTMIN), multiple I\/O events may be queued using the same signal numbers. (Queuing is dependent on available memory). Extra information is available if SA_SIGINFO is set for the signal handler, as above. Note that Linux imposes a limit on the number of real-time signals that may be queued to a process (see getrlimit(2) and signal(7)) and if this limit is reached, then the kernel reverts to delivering SIGIO, and this signal is delivered to the entire process rather than to a specific thread. Using these mechanisms, a program can implement fully asynchronous I\/O without using select(2) or poll(2) most of the time. The use of O_ASYNC, F_GETOWN, F_SETOWN is specific to BSD and Linux. F_GETOWN_EX, F_SETOWN_EX, F_GETSIG, and F_SETSIG are Linux-specific. POSIX has asynchronous I\/O and the aio_sigevent structure to achieve similar things; these are also available in Linux as part of the GNU C Library (Glibc). Leases F_SETLEASE and F_GETLEASE (Linux 2.4 onward) are used (respectively) to establish a new lease, and retrieve the current lease, on the open file description referred to by the file descriptor fd. A file lease provides a mechanism whereby the process holding the lease (the \"lease holder\") is notified (via delivery of a signal) when a process (the \"lease breaker\") tries to open(2) or truncate(2) the file referred to by that file descriptor. F_SETLEASE ( int) Set or remove a file lease according to which of the following values is specified in the integer arg: F_RDLCK Take out a read lease. This will cause the calling process to be notified when the file is opened for writing or is truncated. A read lease can only be placed on a file descriptor that is opened read-only. F_WRLCK Take out a write lease. This will cause the caller to be notified when the file is opened for reading or writing or is truncated. A write lease may be placed on a file only if there are no other open file descriptors for the file. F_UNLCK Remove our lease from the file. Leases are associated with an open file description (see open(2)). This means that duplicate file descriptors (created by, for example, fork(2) or dup(2)) refer to the same lease, and this lease may be modified or released using any of these descriptors. Furthermore, the lease is released by either an explicit F_UNLCK operation on any of these duplicate descriptors, or when all such descriptors have been closed. Leases may only be taken out on regular files. An unprivileged process may only take out a lease on a file whose UID (owner) matches the file system UID of the process. A process with the CAP_LEASE capability may take out leases on arbitrary files. F_GETLEASE ( void) Indicates what type of lease is associated with the file descriptor fd by returning either F_RDLCK, F_WRLCK, or F_UNLCK, indicating, respectively, a read lease , a write lease, or no lease. arg is ignored. When a process (the \"lease breaker\") performs an open(2) or truncate(2) that conflicts with a lease established via F_SETLEASE, the system call is blocked by the kernel and the kernel notifies the lease holder by sending it a signal ( SIGIO by default). The lease holder should respond to receipt of this signal by doing whatever cleanup is required in preparation for the file to be accessed by another process (e.g., flushing cached buffers) and then either remove or downgrade its lease. A lease is removed by performing an F_SETLEASE command specifying arg as F_UNLCK. If the lease holder currently holds a write lease on the file, and the lease breaker is opening the file for reading, then it is sufficient for the lease holder to downgrade the lease to a read lease. This is done by performing an F_SETLEASE command specifying arg as F_RDLCK. If the lease holder fails to downgrade or remove the lease within the number of seconds specified in \/proc\/sys\/fs\/lease-break-time then the kernel forcibly removes or downgrades the lease holder's lease. Once a lease break has been initiated, F_GETLEASE returns the target lease type (either F_RDLCK or F_UNLCK, depending on what would be compatible with the lease breaker) until the lease holder voluntarily downgrades or removes the lease or the kernel forcibly does so after the lease break timer expires. Once the lease has been voluntarily or forcibly removed or downgraded, and assuming the lease breaker has not unblocked its system call, the kernel permits the lease breaker's system call to proceed. If the lease breaker's blocked open(2) or truncate(2) is interrupted by a signal handler, then the system call fails with the error EINTR, but the other steps still occur as described above. If the lease breaker is killed by a signal while blocked in open(2) or truncate(2), then the other steps still occur as described above. If the lease breaker specifies the O_NONBLOCK flag when calling open(2), then the call immediately fails with the error EWOULDBLOCK, but the other steps still occur as described above. The default signal used to notify the lease holder is SIGIO, but this can be changed using the F_SETSIG command to fcntl(). If a F_SETSIG command is performed (even one specifying SIGIO), and the signal handler is established using SA_SIGINFO, then the handler will receive a siginfo_t structure as its second argument, and the si_fd field of this argument will hold the descriptor of the leased file that has been accessed by another process. (This is useful if the caller holds leases against multiple files). File and directory change notification (dnotify) F_NOTIFY ( int) (Linux 2.4 onward) Provide notification when the directory referred to by fd or any of the files that it contains is changed. The events to be notified are specified in arg, which is a bit mask specified by ORing together zero or more of the following bits: DN_ACCESS A file was accessed (read, pread, readv) DN_MODIFY A file was modified (write, pwrite, writev, truncate, ftruncate). DN_CREATE A file was created (open, creat, mknod, mkdir, link, symlink, rename). DN_DELETE A file was unlinked (unlink, rename to another directory, rmdir). DN_RENAME A file was renamed within this directory (rename). DN_ATTRIB The attributes of a file were changed (chown, chmod, utime[s]). (In order to obtain these definitions, the _GNU_SOURCE feature test macro must be defined before including any header files.) Directory notifications are normally \"one-shot\", and the application must reregister to receive further notifications. Alternatively, if DN_MULTISHOT is included in arg, then notification will remain in effect until explicitly removed. A series of F_NOTIFY requests is cumulative, with the events in arg being added to the set already monitored. To disable notification of all events, make an F_NOTIFY call specifying arg as 0. Notification occurs via delivery of a signal. The default signal is SIGIO, but this can be changed using the F_SETSIG command to fcntl(). In the latter case, the signal handler receives a siginfo_t structure as its second argument (if the handler was established using SA_SIGINFO) and the si_fd field of this structure contains the file descriptor which generated the notification (useful when establishing notification on multiple directories). Especially when using DN_MULTISHOT, a real time signal should be used for notification, so that multiple notifications can be queued. NOTE: New applications should use the inotify interface (available since kernel 2.6.13), which provides a much superior interface for obtaining notifications of file system events. See inotify(7). Changing the capacity of a pipe F_SETPIPE_SZ ( int; since Linux 2.6.35) Change the capacity of the pipe referred to by fd to be at least arg bytes. An unprivileged process can adjust the pipe capacity to any value between the system page size and the limit defined in \/proc\/sys\/fs\/pipe-max-size (see proc(5)). Attempts to set the pipe capacity below the page size are silently rounded up to the page size. Attempts by an unprivileged process to set the pipe capacity above the limit in \/proc\/sys\/fs\/pipe-max-size yield the error EPERM; a privileged process ( CAP_SYS_RESOURCE) can override the limit. When allocating the buffer for the pipe, the kernel may use a capacity larger than arg, if that is convenient for the implementation. The F_GETPIPE_SZ operation returns the actual size used. Attempting to set the pipe capacity smaller than the amount of buffer space currently used to store data produces the error EBUSY. F_GETPIPE_SZ ( void; since Linux 2.6.35) Return (as the function result) the capacity of the pipe referred to by fd.","Process Name":"fcntl64","Link":"https:\/\/linux.die.net\/man\/2\/fcntl64"}},{"Process":{"Description":null,"Process Name":"fdatasync","Link":"https:\/\/linux.die.net\/man\/2\/fdatasync"}},{"Process":{"Description":null,"Process Name":"fdetach","Link":"https:\/\/linux.die.net\/man\/2\/fdetach"}},{"Process":{"Description":null,"Process Name":"fgetxattr","Link":"https:\/\/linux.die.net\/man\/2\/fgetxattr"}},{"Process":{"Description":null,"Process Name":"finit_module","Link":"https:\/\/linux.die.net\/man\/2\/finit_module"}},{"Process":{"Description":"Extended attributes are name:value pairs associated with inodes (files, directories, symbolic links, etc.). They are extensions to the normal attributes which are associated with all inodes in the system (i.e., the stat(2) data). A complete overview of extended attributes concepts can be found in attr(5). listxattr() retrieves the list of extended attribute names associated with the given path in the file system. The list is the set of (null-terminated) names, one after the other. Names of extended attributes to which the calling process does not have access may be omitted from the list. The length of the attribute name list is returned. llistxattr() is identical to listxattr(), except in the case of a symbolic link, where the list of names of extended attributes associated with the link itself is retrieved, not the file that it refers to. flistxattr() is identical to listxattr(), only the open file referred to by fd (as returned by open(2)) is interrogated in place of path. A single extended attribute name is a simple null-terminated string. The name includes a namespace prefix; there may be several, disjoint namespaces associated with an individual inode. An empty buffer of size zero can be passed into these calls to return the current size of the list of extended attribute names, which can be used to estimate the size of a buffer which is sufficiently large to hold the list of names. Example The list of names is returned as an unordered array of null-terminated character strings (attribute names are separated by null bytes ('\\0')), like this: user.name1\\0system.name1\\0user.name2\\0 Filesystems like ext2, ext3 and XFS which implement POSIX ACLs using extended attributes, might return a list like this: system.posix_acl_access\\0system.posix_acl_default\\0","Process Name":"flistxattr","Link":"https:\/\/linux.die.net\/man\/2\/flistxattr"}},{"Process":{"Description":null,"Process Name":"flock","Link":"https:\/\/linux.die.net\/man\/2\/flock"}},{"Process":{"Description":null,"Process Name":"fork","Link":"https:\/\/linux.die.net\/man\/2\/fork"}},{"Process":{"Description":null,"Process Name":"free_hugepages","Link":"https:\/\/linux.die.net\/man\/2\/free_hugepages"}},{"Process":{"Description":null,"Process Name":"fremovexattr","Link":"https:\/\/linux.die.net\/man\/2\/fremovexattr"}},{"Process":{"Description":null,"Process Name":"fsetxattr","Link":"https:\/\/linux.die.net\/man\/2\/fsetxattr"}},{"Process":{"Description":null,"Process Name":"fstat","Link":"https:\/\/linux.die.net\/man\/2\/fstat"}},{"Process":{"Description":null,"Process Name":"fstat64","Link":"https:\/\/linux.die.net\/man\/2\/fstat64"}},{"Process":{"Description":null,"Process Name":"fstatat","Link":"https:\/\/linux.die.net\/man\/2\/fstatat"}},{"Process":{"Description":null,"Process Name":"fstatat64","Link":"https:\/\/linux.die.net\/man\/2\/fstatat64"}},{"Process":{"Description":"The function statfs() returns information about a mounted file system. path is the pathname of any file within the mounted file system. buf is a pointer to a statfs structure defined approximately as follows: #if __WORDSIZE == 32 \/* System word size *\/ # define __SWORD_TYPE int #else \/* __WORDSIZE == 64 *\/ # define __SWORD_TYPE long int #endif struct statfs { __SWORD_TYPE f_type; \/* type of file system (see below) *\/ __SWORD_TYPE f_bsize; \/* optimal transfer block size *\/ fsblkcnt_t f_blocks; \/* total data blocks in file system *\/ fsblkcnt_t f_bfree; \/* free blocks in fs *\/ fsblkcnt_t f_bavail; \/* free blocks available to unprivileged user *\/ fsfilcnt_t f_files; \/* total file nodes in file system *\/ fsfilcnt_t f_ffree; \/* free file nodes in fs *\/ fsid_t f_fsid; \/* file system id *\/ __SWORD_TYPE f_namelen; \/* maximum length of filenames *\/ __SWORD_TYPE f_frsize; \/* fragment size (since Linux 2.6) *\/ __SWORD_TYPE f_spare[5]; }; File system types: ADFS_SUPER_MAGIC 0xadf5 AFFS_SUPER_MAGIC 0xADFF BEFS_SUPER_MAGIC 0x42465331 BFS_MAGIC 0x1BADFACE CIFS_MAGIC_NUMBER 0xFF534D42 CODA_SUPER_MAGIC 0x73757245 COH_SUPER_MAGIC 0x012FF7B7 CRAMFS_MAGIC 0x28cd3d45 DEVFS_SUPER_MAGIC 0x1373 EFS_SUPER_MAGIC 0x00414A53 EXT_SUPER_MAGIC 0x137D EXT2_OLD_SUPER_MAGIC 0xEF51 EXT2_SUPER_MAGIC 0xEF53 EXT3_SUPER_MAGIC 0xEF53 EXT4_SUPER_MAGIC 0xEF53 HFS_SUPER_MAGIC 0x4244 HPFS_SUPER_MAGIC 0xF995E849 HUGETLBFS_MAGIC 0x958458f6 ISOFS_SUPER_MAGIC 0x9660 JFFS2_SUPER_MAGIC 0x72b6 JFS_SUPER_MAGIC 0x3153464a MINIX_SUPER_MAGIC 0x137F \/* orig. minix *\/ MINIX_SUPER_MAGIC2 0x138F \/* 30 char minix *\/ MINIX2_SUPER_MAGIC 0x2468 \/* minix V2 *\/ MINIX2_SUPER_MAGIC2 0x2478 \/* minix V2, 30 char names *\/ MSDOS_SUPER_MAGIC 0x4d44 NCP_SUPER_MAGIC 0x564c NFS_SUPER_MAGIC 0x6969 NTFS_SB_MAGIC 0x5346544e OPENPROM_SUPER_MAGIC 0x9fa1 PROC_SUPER_MAGIC 0x9fa0 QNX4_SUPER_MAGIC 0x002f REISERFS_SUPER_MAGIC 0x52654973 ROMFS_MAGIC 0x7275 SMB_SUPER_MAGIC 0x517B SYSV2_SUPER_MAGIC 0x012FF7B6 SYSV4_SUPER_MAGIC 0x012FF7B5 TMPFS_MAGIC 0x01021994 UDF_SUPER_MAGIC 0x15013346 UFS_MAGIC 0x00011954 USBDEVICE_SUPER_MAGIC 0x9fa2 VXFS_SUPER_MAGIC 0xa501FCF5 XENIX_SUPER_MAGIC 0x012FF7B4 XFS_SUPER_MAGIC 0x58465342 _XIAFS_SUPER_MAGIC 0x012FD16D Nobody knows what f_fsid is supposed to contain (but see below). Fields that are undefined for a particular file system are set to 0. fstatfs() returns the same information about an open file referenced by descriptor fd.","Process Name":"fstatfs","Link":"https:\/\/linux.die.net\/man\/2\/fstatfs"}},{"Process":{"Description":null,"Process Name":"fstatfs64","Link":"https:\/\/linux.die.net\/man\/2\/fstatfs64"}},{"Process":{"Description":"The function statvfs() returns information about a mounted file system. path is the pathname of any file within the mounted file system. buf is a pointer to a statvfs structure defined approximately as follows: struct statvfs {\n    unsigned long  f_bsize;    \/* file system block size *\/\n    unsigned long  f_frsize;   \/* fragment size *\/\n    fsblkcnt_t     f_blocks;   \/* size of fs in f_frsize units *\/\n    fsblkcnt_t     f_bfree;    \/* # free blocks *\/\n    fsblkcnt_t     f_bavail;   \/* # free blocks for unprivileged users *\/\n    fsfilcnt_t     f_files;    \/* # inodes *\/\n    fsfilcnt_t     f_ffree;    \/* # free inodes *\/\n    fsfilcnt_t     f_favail;   \/* # free inodes for unprivileged users *\/\n    unsigned long  f_fsid;     \/* file system ID *\/\n    unsigned long  f_flag;     \/* mount flags *\/\n    unsigned long  f_namemax;  \/* maximum filename length *\/\n}; Here the types fsblkcnt_t and fsfilcnt_t are defined in <sys\/types.h>. Both used to be unsigned long. The field f_flag is a bit mask (of mount flags, see mount(8)). Bits defined by POSIX are ST_RDONLY Read-only file system. ST_NOSUID Set-user-ID\/set-group-ID bits are ignored by exec(3). It is unspecified whether all members of the returned struct have meaningful values on all file systems. fstatvfs() returns the same information about an open file referenced by descriptor fd.","Process Name":"fstatvfs","Link":"https:\/\/linux.die.net\/man\/2\/fstatvfs"}},{"Process":{"Description":null,"Process Name":"fsync","Link":"https:\/\/linux.die.net\/man\/2\/fsync"}},{"Process":{"Description":"The truncate() and ftruncate() functions cause the regular file named by path or referenced by fd to be truncated to a size of precisely length bytes. If the file previously was larger than this size, the extra data is lost. If the file previously was shorter, it is extended, and the extended part reads as null bytes ('\\0'). The file offset is not changed. If the size changed, then the st_ctime and st_mtime fields (respectively, time of last status change and time of last modification; see stat(2)) for the file are updated, and the set-user-ID and set-group-ID permission bits may be cleared. With ftruncate(), the file must be open for writing; with truncate(), the file must be writable.","Process Name":"ftruncate","Link":"https:\/\/linux.die.net\/man\/2\/ftruncate"}},{"Process":{"Description":null,"Process Name":"ftruncate64","Link":"https:\/\/linux.die.net\/man\/2\/ftruncate64"}},{"Process":{"Description":"The futex() system call provides a method for a program to wait for a value at a given address to change, and a method to wake up anyone waiting on a particular address (while the addresses for the same memory in separate processes may not be equal, the kernel maps them internally so the same memory mapped in different locations will correspond for futex() calls). This system call is typically used to implement the contended case of a lock in shared memory, as described in futex(7). When a futex(7) operation did not finish uncontended in user space, a call needs to be made to the kernel to arbitrate. Arbitration can either mean putting the calling process to sleep or, conversely, waking a waiting process. Callers of this function are expected to adhere to the semantics as set out in futex(7). As these semantics involve writing nonportable assembly instructions, this in turn probably means that most users will in fact be library authors and not general application developers. The uaddr argument needs to point to an aligned integer which stores the counter. The operation to execute is passed via the op argument, along with a value val. Five operations are currently defined: FUTEX_WAIT This operation atomically verifies that the futex address uaddr still contains the value val, and sleeps awaiting FUTEX_WAKE on this futex address. If the timeout argument is non-NULL, its contents describe the minimum duration of the wait, which is infinite otherwise. The arguments uaddr2 and val3 are ignored. For futex(7), this call is executed if decrementing the count gave a negative value (indicating contention), and will sleep until another process releases the futex and executes the FUTEX_WAKE operation. FUTEX_WAKE This operation wakes at most val processes waiting on this futex address (i.e., inside FUTEX_WAIT). The arguments timeout, uaddr2 and val3 are ignored. For futex(7), this is executed if incrementing the count showed that there were waiters, once the futex value has been set to 1 (indicating that it is available). FUTEX_FD (present up to and including Linux 2.6.25) To support asynchronous wakeups, this operation associates a file descriptor with a futex. If another process executes a FUTEX_WAKE, the process will receive the signal number that was passed in val. The calling process must close the returned file descriptor after use. The arguments timeout, uaddr2 and val3 are ignored. To prevent race conditions, the caller should test if the futex has been upped after FUTEX_FD returns. Because it was inherently racy, FUTEX_FD has been removed from Linux 2.6.26 onward. FUTEX_REQUEUE (since Linux 2.5.70) This operation was introduced in order to avoid a \"thundering herd\" effect when FUTEX_WAKE is used and all processes woken up need to acquire another futex. This call wakes up val processes, and requeues all other waiters on the futex at address uaddr2. The arguments timeout and val3 are ignored. FUTEX_CMP_REQUEUE (since Linux 2.6.7) There was a race in the intended use of FUTEX_REQUEUE, so FUTEX_CMP_REQUEUE was introduced. This is similar to FUTEX_REQUEUE, but first checks whether the location uaddr still contains the value val3. If not, the operation fails with the error EAGAIN. The argument timeout is ignored.","Process Name":"futex","Link":"https:\/\/linux.die.net\/man\/2\/futex"}},{"Process":{"Description":null,"Process Name":"futimesat","Link":"https:\/\/linux.die.net\/man\/2\/futimesat"}}]
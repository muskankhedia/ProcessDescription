[{"Process":{"Description":null,"Process Name":"idle","Link":"https:\/\/linux.die.net\/man\/2\/idle"}},{"Process":{"Description":"These functions return node information obtained from the local route daemon, a modular component of the LAM daemon, regarding the currently running LAM network. A node is defined by its identifier, an arbitrary 32 bit value, and its type, a combination of flags describing the capabilities of the node. These flags (see constants(5) and\/or <net.h>) are: NT_ITB node running LAM natively NT_CAST node multicast, a group of nodes NT_WASTE node not part of main computing group NT_DISK node has a disk NT_TUBE node has a video display unit NT_JONES node is a neighbour of the local node NT_BOOT node is booted by the local node getnodeid() returns the local node identifier. getnodetype() returns the local node type. getorigin() returns the origin node identifier, from which LAM was booted. getncomp() returns the number of nodes marked for the \"main\" computation. A typical application will use most (maybe all) of the nodes in a parallel machine to compute portions of decomposed data. Programmers frequently need to know the number of these \"compute\" nodes. Other nodes may be present in the multicomputer to handle peripherals or sequential portions of an application. getnotb() returns the total number of OTB nodes. getnall() returns the total number of nodes in the system. getnjones() returns the caller's number of neighbour (directly connected) nodes. getntype() is a general function that is used to determine the number of nodes whose node types have certain bits set to certain values. This is a flexible tool which allows the user to obtain very specific information about the capabilities of nodes in the system. Type Inquiries You may need more detailed information on the number and types of nodes in the system than provided by the convenience functions. You may, for example, want to know the number of computing nodes with attached video displays. The getntype() function is used for this purpose. Node types are interpreted as bit fields, and each node type has a different bit set. A bitmask having all bits set, NT_ALL, is also available. Note that NT_ALL does not include NT_JONES nor NT_BOOT since these node characteristics are not inherent to the nodes, but depend on the node from which the query is made. The node types are thus: Nodetype Value Bitmask NT_ITB 1 ...00000001 NT_CAST 2 ...00000010 NT_WASTE 4 ...00000100 NT_DISK 8 ...00001000 NT_TUBE 16 ...00010000 NT_ALL 31 ...00011111 NT_JONES 32 ...00100000 NT_BOOT 64 ...01000000 The typemask argument to getntype() is used to specify which bits are of interest. These are set to 1, all others are set to 0. The nodetype argument is used to specify what values these bits should take. getntype() then compares the relevant bits (as specified by typemask) in the node type of each node in the system, to see if they have the appropriate value (as specified by nodetype). To learn the number of nodes that have video capabilities, the bits of interest are NT_WASTE and NT_TUBE, thus typemask is 20. NT_WASTE must be 0 and NT_TUBE must be 1, which combined gives nodetype as 16. The complete call to getntype() is: nnodes = getntype(NT_TUBE, NT_TUBE | NT_WASTE); To learn the number of compute nodes that have an attached video display, but no other capabilities, all bits must be considered and all bits except NT_TUBE must be clear (0). The complete function call is: nnodes = getntype(NT_TUBE, NT_ALL);","Process Name":"ignall","Link":"https:\/\/linux.die.net\/man\/2\/ignall"}},{"Process":{"Description":null,"Process Name":"igncmp","Link":"https:\/\/linux.die.net\/man\/2\/igncmp"}},{"Process":{"Description":"These functions return node information obtained from the local route daemon, a modular component of the LAM daemon, regarding the currently running LAM network. A node is defined by its identifier, an arbitrary 32 bit value, and its type, a combination of flags describing the capabilities of the node. These flags (see constants(5) and\/or <net.h>) are: NT_ITB node running LAM natively NT_CAST node multicast, a group of nodes NT_WASTE node not part of main computing group NT_DISK node has a disk NT_TUBE node has a video display unit NT_JONES node is a neighbour of the local node NT_BOOT node is booted by the local node getnodeid() returns the local node identifier. getnodetype() returns the local node type. getorigin() returns the origin node identifier, from which LAM was booted. getncomp() returns the number of nodes marked for the \"main\" computation. A typical application will use most (maybe all) of the nodes in a parallel machine to compute portions of decomposed data. Programmers frequently need to know the number of these \"compute\" nodes. Other nodes may be present in the multicomputer to handle peripherals or sequential portions of an application. getnotb() returns the total number of OTB nodes. getnall() returns the total number of nodes in the system. getnjones() returns the caller's number of neighbour (directly connected) nodes. getntype() is a general function that is used to determine the number of nodes whose node types have certain bits set to certain values. This is a flexible tool which allows the user to obtain very specific information about the capabilities of nodes in the system. Type Inquiries You may need more detailed information on the number and types of nodes in the system than provided by the convenience functions. You may, for example, want to know the number of computing nodes with attached video displays. The getntype() function is used for this purpose. Node types are interpreted as bit fields, and each node type has a different bit set. A bitmask having all bits set, NT_ALL, is also available. Note that NT_ALL does not include NT_JONES nor NT_BOOT since these node characteristics are not inherent to the nodes, but depend on the node from which the query is made. The node types are thus: Nodetype Value Bitmask NT_ITB 1 ...00000001 NT_CAST 2 ...00000010 NT_WASTE 4 ...00000100 NT_DISK 8 ...00001000 NT_TUBE 16 ...00010000 NT_ALL 31 ...00011111 NT_JONES 32 ...00100000 NT_BOOT 64 ...01000000 The typemask argument to getntype() is used to specify which bits are of interest. These are set to 1, all others are set to 0. The nodetype argument is used to specify what values these bits should take. getntype() then compares the relevant bits (as specified by typemask) in the node type of each node in the system, to see if they have the appropriate value (as specified by nodetype). To learn the number of nodes that have video capabilities, the bits of interest are NT_WASTE and NT_TUBE, thus typemask is 20. NT_WASTE must be 0 and NT_TUBE must be 1, which combined gives nodetype as 16. The complete call to getntype() is: nnodes = getntype(NT_TUBE, NT_TUBE | NT_WASTE); To learn the number of compute nodes that have an attached video display, but no other capabilities, all bits must be considered and all bits except NT_TUBE must be clear (0). The complete function call is: nnodes = getntype(NT_TUBE, NT_ALL);","Process Name":"igndid","Link":"https:\/\/linux.die.net\/man\/2\/igndid"}},{"Process":{"Description":null,"Process Name":"igndtp","Link":"https:\/\/linux.die.net\/man\/2\/igndtp"}},{"Process":{"Description":null,"Process Name":"ignjon","Link":"https:\/\/linux.die.net\/man\/2\/ignjon"}},{"Process":{"Description":null,"Process Name":"ignotb","Link":"https:\/\/linux.die.net\/man\/2\/ignotb"}},{"Process":{"Description":"These functions return node information obtained from the local route daemon, a modular component of the LAM daemon, regarding the currently running LAM network. A node is defined by its identifier, an arbitrary 32 bit value, and its type, a combination of flags describing the capabilities of the node. These flags (see constants(5) and\/or <net.h>) are: NT_ITB node running LAM natively NT_CAST node multicast, a group of nodes NT_WASTE node not part of main computing group NT_DISK node has a disk NT_TUBE node has a video display unit NT_JONES node is a neighbour of the local node NT_BOOT node is booted by the local node getnodeid() returns the local node identifier. getnodetype() returns the local node type. getorigin() returns the origin node identifier, from which LAM was booted. getncomp() returns the number of nodes marked for the \"main\" computation. A typical application will use most (maybe all) of the nodes in a parallel machine to compute portions of decomposed data. Programmers frequently need to know the number of these \"compute\" nodes. Other nodes may be present in the multicomputer to handle peripherals or sequential portions of an application. getnotb() returns the total number of OTB nodes. getnall() returns the total number of nodes in the system. getnjones() returns the caller's number of neighbour (directly connected) nodes. getntype() is a general function that is used to determine the number of nodes whose node types have certain bits set to certain values. This is a flexible tool which allows the user to obtain very specific information about the capabilities of nodes in the system. Type Inquiries You may need more detailed information on the number and types of nodes in the system than provided by the convenience functions. You may, for example, want to know the number of computing nodes with attached video displays. The getntype() function is used for this purpose. Node types are interpreted as bit fields, and each node type has a different bit set. A bitmask having all bits set, NT_ALL, is also available. Note that NT_ALL does not include NT_JONES nor NT_BOOT since these node characteristics are not inherent to the nodes, but depend on the node from which the query is made. The node types are thus: Nodetype Value Bitmask NT_ITB 1 ...00000001 NT_CAST 2 ...00000010 NT_WASTE 4 ...00000100 NT_DISK 8 ...00001000 NT_TUBE 16 ...00010000 NT_ALL 31 ...00011111 NT_JONES 32 ...00100000 NT_BOOT 64 ...01000000 The typemask argument to getntype() is used to specify which bits are of interest. These are set to 1, all others are set to 0. The nodetype argument is used to specify what values these bits should take. getntype() then compares the relevant bits (as specified by typemask) in the node type of each node in the system, to see if they have the appropriate value (as specified by nodetype). To learn the number of nodes that have video capabilities, the bits of interest are NT_WASTE and NT_TUBE, thus typemask is 20. NT_WASTE must be 0 and NT_TUBE must be 1, which combined gives nodetype as 16. The complete call to getntype() is: nnodes = getntype(NT_TUBE, NT_TUBE | NT_WASTE); To learn the number of compute nodes that have an attached video display, but no other capabilities, all bits must be considered and all bits except NT_TUBE must be clear (0). The complete function call is: nnodes = getntype(NT_TUBE, NT_ALL);","Process Name":"igntp","Link":"https:\/\/linux.die.net\/man\/2\/igntp"}},{"Process":{"Description":null,"Process Name":"igorgn","Link":"https:\/\/linux.die.net\/man\/2\/igorgn"}},{"Process":{"Description":null,"Process Name":"igrtp","Link":"https:\/\/linux.die.net\/man\/2\/igrtp"}},{"Process":{"Description":null,"Process Name":"inb","Link":"https:\/\/linux.die.net\/man\/2\/inb"}},{"Process":{"Description":null,"Process Name":"inb_p","Link":"https:\/\/linux.die.net\/man\/2\/inb_p"}},{"Process":{"Description":null,"Process Name":"init_module","Link":"https:\/\/linux.die.net\/man\/2\/init_module"}},{"Process":{"Description":null,"Process Name":"inl","Link":"https:\/\/linux.die.net\/man\/2\/inl"}},{"Process":{"Description":"This family of functions is used to do low-level port input and output. The out* functions do port output, the in* functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix functions pause until the I\/O completes. They are primarily designed for internal kernel use, but can be used from user space. You must compile with -O or -O2 or similar. The functions are defined as inline macros, and will not be substituted in without optimization enabled, causing unresolved references at link time. You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I\/O ports in question. Failure to do this will cause the application to receive a segmentation fault.","Process Name":"inl_p","Link":"https:\/\/linux.die.net\/man\/2\/inl_p"}},{"Process":{"Description":null,"Process Name":"inotify_add_watch","Link":"https:\/\/linux.die.net\/man\/2\/inotify_add_watch"}},{"Process":{"Description":"inotify_init() initializes a new inotify instance and returns a file descriptor associated with a new inotify event queue. If flags is 0, then inotify_init1() is the same as inotify_init(). The following values can be bitwise ORed in flags to obtain different behavior: IN_NONBLOCK Set the O_NONBLOCK file status flag on the new open file description. Using this flag saves extra calls to fcntl(2) to achieve the same result. IN_CLOEXEC Set the close-on-exec ( FD_CLOEXEC) flag on the new file descriptor. See the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful.","Process Name":"inotify_init","Link":"https:\/\/linux.die.net\/man\/2\/inotify_init"}},{"Process":{"Description":null,"Process Name":"inotify_init1","Link":"https:\/\/linux.die.net\/man\/2\/inotify_init1"}},{"Process":{"Description":"inotify_rm_watch() removes the watch associated with the watch descriptor wd from the inotify instance associated with the file descriptor fd. Removing a watch causes an IN_IGNORED event to be generated for this watch descriptor. (See inotify(7).)","Process Name":"inotify_rm_watch","Link":"https:\/\/linux.die.net\/man\/2\/inotify_rm_watch"}},{"Process":{"Description":null,"Process Name":"insb","Link":"https:\/\/linux.die.net\/man\/2\/insb"}},{"Process":{"Description":null,"Process Name":"insl","Link":"https:\/\/linux.die.net\/man\/2\/insl"}},{"Process":{"Description":null,"Process Name":"insw","Link":"https:\/\/linux.die.net\/man\/2\/insw"}},{"Process":{"Description":null,"Process Name":"intro","Link":"https:\/\/linux.die.net\/man\/2\/intro"}},{"Process":{"Description":null,"Process Name":"introc","Link":"https:\/\/linux.die.net\/man\/2\/introc"}},{"Process":{"Description":"","Process Name":"introf","Link":"https:\/\/linux.die.net\/man\/2\/introf"}},{"Process":{"Description":null,"Process Name":"inw","Link":"https:\/\/linux.die.net\/man\/2\/inw"}},{"Process":{"Description":null,"Process Name":"inw_p","Link":"https:\/\/linux.die.net\/man\/2\/inw_p"}},{"Process":{"Description":null,"Process Name":"io_cancel","Link":"https:\/\/linux.die.net\/man\/2\/io_cancel"}},{"Process":{"Description":null,"Process Name":"io_destroy","Link":"https:\/\/linux.die.net\/man\/2\/io_destroy"}},{"Process":{"Description":null,"Process Name":"io_getevents","Link":"https:\/\/linux.die.net\/man\/2\/io_getevents"}},{"Process":{"Description":null,"Process Name":"io_setup","Link":"https:\/\/linux.die.net\/man\/2\/io_setup"}},{"Process":{"Description":null,"Process Name":"io_submit","Link":"https:\/\/linux.die.net\/man\/2\/io_submit"}},{"Process":{"Description":null,"Process Name":"ioctl","Link":"https:\/\/linux.die.net\/man\/2\/ioctl"}},{"Process":{"Description":"This is Ioctl List 1.3.27, a list of ioctl calls in Linux\/i386 kernel 1.3.27. It contains 421 ioctls from <\/usr\/include\/{asm,linux}\/*.h>. For each ioctl, its numerical value, its name, and its argument type are given. An argument type of const struct foo * means the argument is input to the kernel. struct foo * means the kernel outputs the argument. If the kernel uses the argument for both input and output, this is marked with \/\/ I-O. Some ioctls take more arguments or return more values than a single structure. These are marked \/\/ MORE and documented further in a separate section. This list is very incomplete. ioctl structure Ioctl command values are 32-bit constants. In principle these constants are completely arbitrary, but people have tried to build some structure into them. The old Linux situation was that of mostly 16-bit constants, where the last byte is a serial number, and the preceding byte(s) give a type indicating the driver. Sometimes the major number was used: 0x03 for the HDIO_* ioctls, 0x06 for the LP* ioctls. And sometimes one or more ASCII letters were used. For example, TCGETS has value 0x00005401, with 0x54 = aqTaq indicating the terminal driver, and CYGETTIMEOUT has value 0x00435906, with 0x43 0x59 = aqCaq aqYaq indicating the cyclades driver. Later (0.98p5) some more information was built into the number. One has 2 direction bits (00: none, 01: write, 10: read, 11: read\/write) followed by 14 size bits (giving the size of the argument), followed by an 8-bit type (collecting the ioctls in groups for a common purpose or a common driver), and an 8-bit serial number. The macros describing this structure live in <asm\/ioctl.h> and are _IO(type,nr) and {_IOR,_IOW,_IOWR}(type,nr,size). They use sizeof(size) so that size is a misnomer here: this third argument is a data type. Note that the size bits are very unreliable: in lots of cases they are wrong, either because of buggy macros using sizeof(sizeof(struct)), or because of legacy values. Thus, it seems that the new structure only gave disadvantages: it does not help in checking, but it causes varying values for the various architectures.","Process Name":"ioctl_list","Link":"https:\/\/linux.die.net\/man\/2\/ioctl_list"}},{"Process":{"Description":null,"Process Name":"ioperm","Link":"https:\/\/linux.die.net\/man\/2\/ioperm"}},{"Process":{"Description":"iopl() changes the I\/O privilege level of the calling process, as specified by the two least significant bits in level. This call is necessary to allow 8514-compatible X servers to run under Linux. Since these X servers require access to all 65536 I\/O ports, the ioperm(2) call is not sufficient. In addition to granting unrestricted I\/O port access, running at a higher I\/O privilege level also allows the process to disable interrupts. This will probably crash the system, and is not recommended. Permissions are inherited by fork(2) and execve(2). The I\/O privilege level for a normal process is 0. This call is mostly for the i386 architecture. On many other architectures it does not exist or will always return an error.","Process Name":"iopl","Link":"https:\/\/linux.die.net\/man\/2\/iopl"}},{"Process":{"Description":null,"Process Name":"ioprio_get","Link":"https:\/\/linux.die.net\/man\/2\/ioprio_get"}},{"Process":{"Description":"The ioprio_get() and ioprio_set() system calls respectively get and set the I\/O scheduling class and priority of one or more threads. The which and who arguments identify the thread(s) on which the system calls operate. The which argument determines how who is interpreted, and has one of the following values: IOPRIO_WHO_PROCESS who is a process ID or thread ID identifying a single process or thread. If who is 0, then operate on the calling thread. IOPRIO_WHO_PGRP who is a process group ID identifying all the members of a process group. If who is 0, then operate on the process group of which the caller is a member. IOPRIO_WHO_USER who is a user ID identifying all of the processes that have a matching real UID. If which is specified as IOPRIO_WHO_PGRP or IOPRIO_WHO_USER when calling ioprio_get(), and more than one process matches who, then the returned priority will be the highest one found among all of the matching processes. One priority is said to be higher than another one if it belongs to a higher priority class (IOPRIO_CLASS_RT is the highest priority class; IOPRIO_CLASS_IDLE is the lowest) or if it belongs to the same priority class as the other process but has a higher priority level (a lower priority number means a higher priority level). The ioprio argument given to ioprio_set() is a bit mask that specifies both the scheduling class and the priority to be assigned to the target process(es). The following macros are used for assembling and dissecting ioprio values: IOPRIO_PRIO_VALUE( class , data ) Given a scheduling class and priority ( data), this macro combines the two values to produce an ioprio value, which is returned as the result of the macro. IOPRIO_PRIO_CLASS( mask ) Given mask (an ioprio value), this macro returns its I\/O class component, that is, one of the values IOPRIO_CLASS_RT, IOPRIO_CLASS_BE, or IOPRIO_CLASS_IDLE. IOPRIO_PRIO_DATA( mask ) Given mask (an ioprio value), this macro returns its priority ( data) component. See the NOTES section for more information on scheduling classes and priorities. I\/O priorities are supported for reads and for synchronous (O_DIRECT, O_SYNC) writes. I\/O priorities are not supported for asynchronous writes because they are issued outside the context of the program dirtying the memory, and thus program-specific priorities do not apply.","Process Name":"ioprio_set","Link":"https:\/\/linux.die.net\/man\/2\/ioprio_set"}},{"Process":{"Description":null,"Process Name":"ipc","Link":"https:\/\/linux.die.net\/man\/2\/ipc"}},{"Process":{"Description":null,"Process Name":"isastream","Link":"https:\/\/linux.die.net\/man\/2\/isastream"}}]
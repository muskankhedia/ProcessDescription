[{"Process":{"Description":"The message packet is identified solely by a sequence number, seq. Sequence numbers of buffered packets are learned by a prior call to rbfstate(2). Note that the packets and their sequence numbers reported by rbfstate(2) are only a snapshot of a buffer daemon's state. When rbflook() is called, some or all of packets reported by rbfstate(2) may have been forwarded and new ones (with unknown sequence numbers) may have arrived. The most useful application of rbflook() is to debug a blocked system of processes and messages. The nh argument is a network message descriptor that is only used to supply a packet buffer and maximum packet length (up to MAXNMSGLEN, defined in <net.h>). The synchronization fields of the descriptor are not used. Only the sequence number identifies the message packet.","Process Name":"rbflook","Link":"https:\/\/linux.die.net\/man\/2\/rbflook"}},{"Process":{"Description":null,"Process Name":"rbfparms","Link":"https:\/\/linux.die.net\/man\/2\/rbfparms"}},{"Process":{"Description":null,"Process Name":"rbfstate","Link":"https:\/\/linux.die.net\/man\/2\/rbfstate"}},{"Process":{"Description":null,"Process Name":"rbfsweep","Link":"https:\/\/linux.die.net\/man\/2\/rbfsweep"}},{"Process":{"Description":null,"Process Name":"rbfudie","Link":"https:\/\/linux.die.net\/man\/2\/rbfudie"}},{"Process":{"Description":null,"Process Name":"rbfwipe","Link":"https:\/\/linux.die.net\/man\/2\/rbfwipe"}},{"Process":{"Description":"read() attempts to read up to count bytes from file descriptor fd into the buffer starting at buf. On files that support seeking, the read operation commences at the current file offset, and the file offset is incremented by the number of bytes read. If the current file offset is at or past the end of file, no bytes are read, and read() returns zero. If count is zero, read() may detect the errors described below. In the absence of any errors, or if read() does not check for errors, a read() with a count of 0 returns zero and has no other effects. If count is greater than SSIZE_MAX, the result is unspecified.","Process Name":"read","Link":"https:\/\/linux.die.net\/man\/2\/read"}},{"Process":{"Description":null,"Process Name":"readahead","Link":"https:\/\/linux.die.net\/man\/2\/readahead"}},{"Process":{"Description":null,"Process Name":"readdir","Link":"https:\/\/linux.die.net\/man\/2\/readdir"}},{"Process":{"Description":null,"Process Name":"readlink","Link":"https:\/\/linux.die.net\/man\/2\/readlink"}},{"Process":{"Description":null,"Process Name":"readlinkat","Link":"https:\/\/linux.die.net\/man\/2\/readlinkat"}},{"Process":{"Description":null,"Process Name":"readv","Link":"https:\/\/linux.die.net\/man\/2\/readv"}},{"Process":{"Description":null,"Process Name":"reboot","Link":"https:\/\/linux.die.net\/man\/2\/reboot"}},{"Process":{"Description":null,"Process Name":"recho","Link":"https:\/\/linux.die.net\/man\/2\/recho"}},{"Process":{"Description":null,"Process Name":"recv","Link":"https:\/\/linux.die.net\/man\/2\/recv"}},{"Process":{"Description":null,"Process Name":"recvfrom","Link":"https:\/\/linux.die.net\/man\/2\/recvfrom"}},{"Process":{"Description":null,"Process Name":"recvmmsg","Link":"https:\/\/linux.die.net\/man\/2\/recvmmsg"}},{"Process":{"Description":null,"Process Name":"recvmsg","Link":"https:\/\/linux.die.net\/man\/2\/recvmsg"}},{"Process":{"Description":null,"Process Name":"remap_file_pages","Link":"https:\/\/linux.die.net\/man\/2\/remap_file_pages"}},{"Process":{"Description":"Extended attributes are name:value pairs associated with inodes (files, directories, symbolic links, etc.). They are extensions to the normal attributes which are associated with all inodes in the system (i.e., the stat(2) data). A complete overview of extended attributes concepts can be found in attr(5). removexattr() removes the extended attribute identified by name and associated with the given path in the file system. lremovexattr() is identical to removexattr(), except in the case of a symbolic link, where the extended attribute is removed from the link itself, not the file that it refers to. fremovexattr() is identical to removexattr(), only the extended attribute is removed from the open file referred to by fd (as returned by open(2)) in place of path. An extended attribute name is a simple null-terminated string. The name includes a namespace prefix; there may be several, disjoint namespaces associated with an individual inode.","Process Name":"removexattr","Link":"https:\/\/linux.die.net\/man\/2\/removexattr"}},{"Process":{"Description":null,"Process Name":"rename","Link":"https:\/\/linux.die.net\/man\/2\/rename"}},{"Process":{"Description":null,"Process Name":"renameat","Link":"https:\/\/linux.die.net\/man\/2\/renameat"}},{"Process":{"Description":null,"Process Name":"request_key","Link":"https:\/\/linux.die.net\/man\/2\/request_key"}},{"Process":{"Description":null,"Process Name":"restart_syscall","Link":"https:\/\/linux.die.net\/man\/2\/restart_syscall"}},{"Process":{"Description":null,"Process Name":"rflat","Link":"https:\/\/linux.die.net\/man\/2\/rflat"}},{"Process":{"Description":"The tag serves as a symbolic name, and is not related to the actual address of the allocated remote storage. The flat daemon remembers the tag. A later call to rget(2) can retrieve the actual address of the storage. The ld_length and ma_length arguments are almost always set to the same value. A larger value for ma_length (the only other possibility) allows extra contiguous storage to be allocated but not loaded. The rflclean() function frees any storage associated with the flat tag. It also deletes the flat tag.","Process Name":"rflclean","Link":"https:\/\/linux.die.net\/man\/2\/rflclean"}},{"Process":{"Description":null,"Process Name":"rforget","Link":"https:\/\/linux.die.net\/man\/2\/rforget"}},{"Process":{"Description":null,"Process Name":"rget","Link":"https:\/\/linux.die.net\/man\/2\/rget"}},{"Process":{"Description":"The transfer is done by the load daemon on the source node using the flat daemon on the destination node. See rflat(2). After returning from rload() the tag can be converted to a local address on the destination node using rget(2).","Process Name":"rload","Link":"https:\/\/linux.die.net\/man\/2\/rload"}},{"Process":{"Description":null,"Process Name":"rmdir","Link":"https:\/\/linux.die.net\/man\/2\/rmdir"}},{"Process":{"Description":null,"Process Name":"rpcreate","Link":"https:\/\/linux.die.net\/man\/2\/rpcreate"}},{"Process":{"Description":null,"Process Name":"rpdoom","Link":"https:\/\/linux.die.net\/man\/2\/rpdoom"}},{"Process":{"Description":null,"Process Name":"rpgo","Link":"https:\/\/linux.die.net\/man\/2\/rpgo"}},{"Process":{"Description":null,"Process Name":"rpldgo","Link":"https:\/\/linux.die.net\/man\/2\/rpldgo"}},{"Process":{"Description":null,"Process Name":"rploadgo","Link":"https:\/\/linux.die.net\/man\/2\/rploadgo"}},{"Process":{"Description":null,"Process Name":"rpspawn","Link":"https:\/\/linux.die.net\/man\/2\/rpspawn"}},{"Process":{"Description":"Selection Methods Processes to be reported from the target node are selected by one of several methods, chosen in the sflags argument. The selection method codes are defined in <preq.h>. SELECT_PID Select by process ID. The svalue argument contains the process ID. SELECT_INDEX Select by process table index. The svalue argument contains the index. SELECT_APPL Select all application (user) processes. SELECT_SYS Select all system processes. SELECT_ALL Select all application and all system processes. Remote Process Status The status structure array, stat_tab, is filled with information on the selected processes. The structure is defined in <preq.h>. struct pstate {\n    int        ps_reply;\n    int        ps_index;\n    int        ps_pid;\n    int        ps_rtf;\n    int        ps_nodeid;\n    int        ps_event;\n    struct kstatus    ps_kernel;\n    char        ps_name[PSMAXNAME];\n    char        ps_loadpt[PSMAXNAME];\n}; ps_reply internal use by rpstate() ps_index index within target node ps_pid identifier within target node ps_rtf runtime flags, see rploadgo(2) ps_nodeid parent's node identifier ps_event parent's event for reporting process's exit ps_kernel kernel status, see kstate(2) ps_name argv[0], usually the program name, see kenter(2) ps_loadpt load module filename","Process Name":"rpstate","Link":"https:\/\/linux.die.net\/man\/2\/rpstate"}},{"Process":{"Description":null,"Process Name":"rpwait","Link":"https:\/\/linux.die.net\/man\/2\/rpwait"}},{"Process":{"Description":null,"Process Name":"rpwt","Link":"https:\/\/linux.die.net\/man\/2\/rpwt"}},{"Process":{"Description":null,"Process Name":"rrsetrents","Link":"https:\/\/linux.die.net\/man\/2\/rrsetrents"}},{"Process":{"Description":"The sigaction() system call is used to change the action taken by a process on receipt of a specific signal. (See signal(7) for an overview of signals.) signum specifies the signal and can be any valid signal except SIGKILL and SIGSTOP. If act is non-NULL, the new action for signal signum is installed from act. If oldact is non-NULL, the previous action is saved in oldact. The sigaction structure is defined as something like: struct sigaction {\n    void     (*sa_handler)(int);\n    void     (*sa_sigaction)(int, siginfo_t *, void *);\n    sigset_t   sa_mask;\n    int        sa_flags;\n    void     (*sa_restorer)(void);\n}; On some architectures a union is involved: do not assign to both sa_handler and sa_sigaction. The sa_restorer element is obsolete and should not be used. POSIX does not specify a sa_restorer element. sa_handler specifies the action to be associated with signum and may be SIG_DFL for the default action, SIG_IGN to ignore this signal, or a pointer to a signal handling function. This function receives the signal number as its only argument. If SA_SIGINFO is specified in sa_flags, then sa_sigaction (instead of sa_handler) specifies the signal-handling function for signum. This function receives the signal number as its first argument, a pointer to a siginfo_t as its second argument and a pointer to a ucontext_t (cast to void *) as its third argument. (Commonly, the handler function doesn't make any use of the third argument. See getcontext(3) for further information about ucontext_t.) sa_mask specifies a mask of signals which should be blocked (i.e., added to the signal mask of the thread in which the signal handler is invoked) during execution of the signal handler. In addition, the signal which triggered the handler will be blocked, unless the SA_NODEFER flag is used. sa_flags specifies a set of flags which modify the behavior of the signal. It is formed by the bitwise OR of zero or more of the following: SA_NOCLDSTOP If signum is SIGCHLD, do not receive notification when child processes stop (i.e., when they receive one of SIGSTOP, SIGTSTP, SIGTTIN or SIGTTOU) or resume (i.e., they receive SIGCONT) (see wait(2)). This flag is only meaningful when establishing a handler for SIGCHLD. SA_NOCLDWAIT (since Linux 2.6) If signum is SIGCHLD, do not transform children into zombies when they terminate. See also waitpid(2). This flag is only meaningful when establishing a handler for SIGCHLD, or when setting that signal's disposition to SIG_DFL. If the SA_NOCLDWAIT flag is set when establishing a handler for SIGCHLD, POSIX.1 leaves it unspecified whether a SIGCHLD signal is generated when a child process terminates. On Linux, a SIGCHLD signal is generated in this case; on some other implementations, it is not. SA_NODEFER Do not prevent the signal from being received from within its own signal handler. This flag is only meaningful when establishing a signal handler. SA_NOMASK is an obsolete, nonstandard synonym for this flag. SA_ONSTACK Call the signal handler on an alternate signal stack provided by sigaltstack(2). If an alternate stack is not available, the default stack will be used. This flag is only meaningful when establishing a signal handler. SA_RESETHAND Restore the signal action to the default upon entry to the signal handler. This flag is only meaningful when establishing a signal handler. SA_ONESHOT is an obsolete, nonstandard synonym for this flag. SA_RESTART Provide behavior compatible with BSD signal semantics by making certain system calls restartable across signals. This flag is only meaningful when establishing a signal handler. See signal(7) for a discussion of system call restarting. SA_SIGINFO (since Linux 2.2) The signal handler takes three arguments, not one. In this case, sa_sigaction should be set instead of sa_handler. This flag is only meaningful when establishing a signal handler. The siginfo_t argument to sa_sigaction is a struct with the following elements: siginfo_t {\n    int      si_signo;    \/* Signal number *\/\n    int      si_errno;    \/* An errno value *\/\n    int      si_code;     \/* Signal code *\/\n    int      si_trapno;   \/* Trap number that caused\n                             hardware-generated signal\n                             (unused on most architectures) *\/\n    pid_t    si_pid;      \/* Sending process ID *\/\n    uid_t    si_uid;      \/* Real user ID of sending process *\/\n    int      si_status;   \/* Exit value or signal *\/\n    clock_t  si_utime;    \/* User time consumed *\/\n    clock_t  si_stime;    \/* System time consumed *\/\n    sigval_t si_value;    \/* Signal value *\/\n    int      si_int;      \/* POSIX.1b signal *\/\n    void    *si_ptr;      \/* POSIX.1b signal *\/\n    int      si_overrun;  \/* Timer overrun count; POSIX.1b timers *\/\n    int      si_timerid;  \/* Timer ID; POSIX.1b timers *\/\n    void    *si_addr;     \/* Memory location which caused fault *\/\n    long     si_band;     \/* Band event (was int in\n                             glibc 2.3.2 and earlier) *\/\n    int      si_fd;       \/* File descriptor *\/\n    short    si_addr_lsb; \/* Least significant bit of address\n                             (since kernel 2.6.32) *\/\n} si_signo, si_errno and si_code are defined for all signals. ( si_errno is generally unused on Linux.) The rest of the struct may be a union, so that one should only read the fields that are meaningful for the given signal: * Signals sent with kill(2) and sigqueue(3) fill in si_pid and si_uid. In addition, signals sent with sigqueue(3) fill in si_int and si_ptr with the values specified by the sender of the signal; see sigqueue(3) for more details. * Signals sent by POSIX.1b timers (since Linux 2.6) fill in si_overrun and si_timerid. The si_timerid field is an internal ID used by the kernel to identify the timer; it is not the same as the timer ID returned by timer_create(2). The si_overrun field is the timer overrun count; this is the same information as is obtained by a call to timer_getoverrun(2). These fields are nonstandard Linux extensions. * Signals sent for message queue notification (see the description of SIGEV_SIGNAL in mq_notify(3)) fill in si_int\/si_ptr, with the sigev_value supplied to mq_notify(3); si_pid, with the process ID of the message sender; and si_uid, with the real user ID of the message sender. * SIGCHLD fills in si_pid, si_uid, si_status, si_utime and si_stime, providing information about the child. The si_pid field is the process ID of the child; si_uid is the child's real user ID. The si_status field contains the exit status of the child (if si_code is CLD_EXITED), or the signal number that caused the process to change state. The si_utime and si_stime contain the user and system CPU time used by the child process; these fields do not include the times used by waited-for children (unlike getrusage(2) and time(2)). In kernels up to 2.6, and since 2.6.27, these fields report CPU time in units of sysconf(_SC_CLK_TCK). In 2.6 kernels before 2.6.27, a bug meant that these fields reported time in units of the (configurable) system jiffy (see time(7)). * SIGILL, SIGFPE, SIGSEGV, SIGBUS, and SIGTRAP fill in si_addr with the address of the fault. On some architectures, these signals also fill in the si_trapno filed. Some suberrors of SIGBUS, in particular BUS_MCEERR_AO and BUS_MCEERR_AR, also fill in si_addr_lsb. This field indicates the least significant bit of the reported address and therefore the extent of the corruption. For example, if a full page was corrupted, si_addr_lsb contains log2(sysconf(_SC_PAGESIZE)). BUS_MCERR_* and si_addr_lsb are Linux-specific extensions. * SIGIO\/SIGPOLL (the two names are synonyms on Linux) fills in si_band and si_fd. The si_band event is a bit mask containing the same values as are filled in the revents field by poll(2). The si_fd field indicates the file descriptor for which the I\/O event occurred. si_code is a value (not a bit mask) indicating why this signal was sent. The following list shows the values which can be placed in si_code for any signal, along with reason that the signal was generated. SI_USER kill(2) SI_KERNEL Sent by the kernel. SI_QUEUE sigqueue(3) SI_TIMER POSIX timer expired SI_MESGQ POSIX message queue state changed (since Linux 2.6.6); see mq_notify(3) SI_ASYNCIO AIO completed SI_SIGIO Queued SIGIO (only in kernels up to Linux 2.2; from Linux 2.4 onward SIGIO\/SIGPOLL fills in si_code as described below). SI_TKILL tkill(2) or tgkill(2) (since Linux 2.4.19) The following values can be placed in si_code for a SIGILL signal: ILL_ILLOPC illegal opcode ILL_ILLOPN illegal operand ILL_ILLADR illegal addressing mode ILL_ILLTRP illegal trap ILL_PRVOPC privileged opcode ILL_PRVREG privileged register ILL_COPROC coprocessor error ILL_BADSTK internal stack error The following values can be placed in si_code for a SIGFPE signal: FPE_INTDIV integer divide by zero FPE_INTOVF integer overflow FPE_FLTDIV floating-point divide by zero FPE_FLTOVF floating-point overflow FPE_FLTUND floating-point underflow FPE_FLTRES floating-point inexact result FPE_FLTINV floating-point invalid operation FPE_FLTSUB subscript out of range The following values can be placed in si_code for a SIGSEGV signal: SEGV_MAPERR address not mapped to object SEGV_ACCERR invalid permissions for mapped object The following values can be placed in si_code for a SIGBUS signal: BUS_ADRALN invalid address alignment BUS_ADRERR nonexistent physical address BUS_OBJERR object-specific hardware error BUS_MCEERR_AR (since Linux 2.6.32) Hardware memory error consumed on a machine check; action required. BUS_MCEERR_AO (since Linux 2.6.32) Hardware memory error detected in process but not consumed; action optional. The following values can be placed in si_code for a SIGTRAP signal: TRAP_BRKPT process breakpoint TRAP_TRACE process trace trap TRAP_BRANCH (since Linux 2.4) process taken branch trap TRAP_HWBKPT (since Linux 2.4) hardware breakpoint\/watchpoint The following values can be placed in si_code for a SIGCHLD signal: CLD_EXITED child has exited CLD_KILLED child was killed CLD_DUMPED child terminated abnormally CLD_TRAPPED traced child has trapped CLD_STOPPED child has stopped CLD_CONTINUED stopped child has continued (since Linux 2.6.9) The following values can be placed in si_code for a SIGIO\/ SIGPOLL signal: POLL_IN data input available POLL_OUT output buffers available POLL_MSG input message available POLL_ERR I\/O error POLL_PRI high priority input available POLL_HUP device disconnected","Process Name":"rt_sigaction","Link":"https:\/\/linux.die.net\/man\/2\/rt_sigaction"}},{"Process":{"Description":null,"Process Name":"rt_sigpending","Link":"https:\/\/linux.die.net\/man\/2\/rt_sigpending"}},{"Process":{"Description":"sigprocmask() is used to fetch and\/or change the signal mask of the calling thread. The signal mask is the set of signals whose delivery is currently blocked for the caller (see also signal(7) for more details). The behavior of the call is dependent on the value of how, as follows. SIG_BLOCK The set of blocked signals is the union of the current set and the set argument. SIG_UNBLOCK The signals in set are removed from the current set of blocked signals. It is permissible to attempt to unblock a signal which is not blocked. SIG_SETMASK The set of blocked signals is set to the argument set. If oldset is non-NULL, the previous value of the signal mask is stored in oldset. If set is NULL, then the signal mask is unchanged (i.e., how is ignored), but the current value of the signal mask is nevertheless returned in oldset (if it is not NULL). The use of sigprocmask() is unspecified in a multithreaded process; see pthread_sigmask(3).","Process Name":"rt_sigprocmask","Link":"https:\/\/linux.die.net\/man\/2\/rt_sigprocmask"}},{"Process":{"Description":null,"Process Name":"rt_sigqueueinfo","Link":"https:\/\/linux.die.net\/man\/2\/rt_sigqueueinfo"}},{"Process":{"Description":"When the Linux kernel creates the stack frame for a signal handler, a call to sigreturn() is inserted into the stack frame so that upon return from the signal handler, sigreturn() will be called. This sigreturn() call undoes everything that was done--changing the process's signal mask, switching stacks (see sigaltstack(2))--in order to invoke the signal handler: it restores the process's signal mask, switches stacks, and restores the process's context (registers, processor flags), so that the process directly resumes execution at the point where it was interrupted by the signal.","Process Name":"rt_sigreturn","Link":"https:\/\/linux.die.net\/man\/2\/rt_sigreturn"}},{"Process":{"Description":null,"Process Name":"rt_sigsuspend","Link":"https:\/\/linux.die.net\/man\/2\/rt_sigsuspend"}},{"Process":{"Description":null,"Process Name":"rt_sigtimedwait","Link":"https:\/\/linux.die.net\/man\/2\/rt_sigtimedwait"}},{"Process":{"Description":null,"Process Name":"rt_tgsigqueueinfo","Link":"https:\/\/linux.die.net\/man\/2\/rt_tgsigqueueinfo"}},{"Process":{"Description":null,"Process Name":"rtas","Link":"https:\/\/linux.die.net\/man\/2\/rtas"}}]
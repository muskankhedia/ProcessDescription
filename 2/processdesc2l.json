[{"Process":{"Description":null,"Process Name":"llseek","Link":"https:\/\/linux.die.net\/man\/2\/llseek"}},{"Process":{"Description":"These system calls are not implemented in the Linux kernel.","Process Name":"lock","Link":"https:\/\/linux.die.net\/man\/2\/lock"}},{"Process":{"Description":null,"Process Name":"lookup_dcookie","Link":"https:\/\/linux.die.net\/man\/2\/lookup_dcookie"}},{"Process":{"Description":"Remote process management allows a process to be selected by other processes throughout the multicomputer for control or monitoring in such functions as rpdoom(2), rpstate(2) and rpspawn(2). The name argument helps identify the process. It is useful to choose the program name, as found in argv[0], for this argument. The name will be seen in the output of the state(1) command. lpattach() is called by kenter(2) and is not typically called directly. The function lpdetach() makes a LAM process inaccessible to remote process management and should be called just prior to process termination. The status argument is an exit code. If a parent process is waiting for the calling process to terminate, lpdetach() will pass the termination status back to the parent. lpdetach() is called by kexit(2) and is not typically called directly. The pid argument makes it possible for one process to remove another from remote process management. This is intended as an emergency clean-up measure. The normal value for this argument is 0, which indicates the action is to be taken on the calling process.","Process Name":"lpattach","Link":"https:\/\/linux.die.net\/man\/2\/lpattach"}},{"Process":{"Description":null,"Process Name":"lpdetach","Link":"https:\/\/linux.die.net\/man\/2\/lpdetach"}},{"Process":{"Description":"Extended attributes are name:value pairs associated with inodes (files, directories, symbolic links, etc.). They are extensions to the normal attributes which are associated with all inodes in the system (i.e., the stat(2) data). A complete overview of extended attributes concepts can be found in attr(5). removexattr() removes the extended attribute identified by name and associated with the given path in the file system. lremovexattr() is identical to removexattr(), except in the case of a symbolic link, where the extended attribute is removed from the link itself, not the file that it refers to. fremovexattr() is identical to removexattr(), only the extended attribute is removed from the open file referred to by fd (as returned by open(2)) in place of path. An extended attribute name is a simple null-terminated string. The name includes a namespace prefix; there may be several, disjoint namespaces associated with an individual inode.","Process Name":"lremovexattr","Link":"https:\/\/linux.die.net\/man\/2\/lremovexattr"}},{"Process":{"Description":null,"Process Name":"lseek","Link":"https:\/\/linux.die.net\/man\/2\/lseek"}},{"Process":{"Description":"Extended attributes are name:value pairs associated with inodes (files, directories, symbolic links, etc.). They are extensions to the normal attributes which are associated with all inodes in the system (i.e., the stat(2) data). A complete overview of extended attributes concepts can be found in attr(5). setxattr() sets the value of the extended attribute identified by name and associated with the given path in the file system. The size of the value must be specified. lsetxattr() is identical to setxattr(), except in the case of a symbolic link, where the extended attribute is set on the link itself, not the file that it refers to. fsetxattr() is identical to setxattr(), only the extended attribute is set on the open file referred to by fd (as returned by open(2)) in place of path. An extended attribute name is a simple null-terminated string. The name includes a namespace prefix; there may be several, disjoint namespaces associated with an individual inode. The value of an extended attribute is a chunk of arbitrary textual or binary data of specified length. The flags argument can be used to refine the semantics of the operation. XATTR_CREATE specifies a pure create, which fails if the named attribute exists already. XATTR_REPLACE specifies a pure replace operation, which fails if the named attribute does not already exist. By default (no flags), the extended attribute will be created if need be, or will simply replace the value if the attribute exists.","Process Name":"lsetxattr","Link":"https:\/\/linux.die.net\/man\/2\/lsetxattr"}},{"Process":{"Description":null,"Process Name":"lstat","Link":"https:\/\/linux.die.net\/man\/2\/lstat"}},{"Process":{"Description":"These functions return information about a file. No permissions are required on the file itself, but-in the case of stat() and lstat() - execute (search) permission is required on all of the directories in path that lead to the file. stat() stats the file pointed to by path and fills in buf. lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to. fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd. All of these system calls return a stat structure, which contains the following fields: struct stat {\n    dev_t     st_dev;     \/* ID of device containing file *\/\n    ino_t     st_ino;     \/* inode number *\/\n    mode_t    st_mode;    \/* protection *\/\n    nlink_t   st_nlink;   \/* number of hard links *\/\n    uid_t     st_uid;     \/* user ID of owner *\/\n    gid_t     st_gid;     \/* group ID of owner *\/\n    dev_t     st_rdev;    \/* device ID (if special file) *\/\n    off_t     st_size;    \/* total size, in bytes *\/\n    blksize_t st_blksize; \/* blocksize for file system I\/O *\/\n    blkcnt_t  st_blocks;  \/* number of 512B blocks allocated *\/\n    time_t    st_atime;   \/* time of last access *\/\n    time_t    st_mtime;   \/* time of last modification *\/\n    time_t    st_ctime;   \/* time of last status change *\/\n}; The st_dev field describes the device on which this file resides. (The major(3) and minor(3) macros may be useful to decompose the device ID in this field.) The st_rdev field describes the device that this file (inode) represents. The st_size field gives the size of the file (if it is a regular file or a symbolic link) in bytes. The size of a symbolic link is the length of the pathname it contains, without a terminating null byte. The st_blocks field indicates the number of blocks allocated to the file, 512-byte units. (This may be smaller than st_size\/512 when the file has holes.) The st_blksize field gives the \"preferred\" blocksize for efficient file system I\/O. (Writing to a file in smaller chunks may cause an inefficient read-modify-rewrite.) Not all of the Linux file systems implement all of the time fields. Some file system types allow mounting in such a way that file and\/or directory accesses do not cause an update of the st_atime field. (See noatime, nodiratime, and relatime in mount(8), and related information in mount(2).) In addition, st_atime is not updated if a file is opened with the O_NOATIME; see open(2). The field st_atime is changed by file accesses, for example, by execve(2), mknod(2), pipe(2), utime(2) and read(2) (of more than zero bytes). Other routines, like mmap(2), may or may not update st_atime. The field st_mtime is changed by file modifications, for example, by mknod(2), truncate(2), utime(2) and write(2) (of more than zero bytes). Moreover, st_mtime of a directory is changed by the creation or deletion of files in that directory. The st_mtime field is not changed for changes in owner, group, hard link count, or mode. The field st_ctime is changed by writing or by setting inode information (i.e., owner, group, link count, mode, etc.). The following POSIX macros are defined to check the file type using the st_mode field: S_ISREG(m) is it a regular file? S_ISDIR(m) directory? S_ISCHR(m) character device? S_ISBLK(m) block device? S_ISFIFO(m) FIFO (named pipe)? S_ISLNK(m) symbolic link? (Not in POSIX.1-1996.) S_ISSOCK(m) socket? (Not in POSIX.1-1996.) The following flags are defined for the st_mode field: The set-group-ID bit ( S_ISGID) has several special uses. For a directory it indicates that BSD semantics is to be used for that directory: files created there inherit their group ID from the directory, not from the effective group ID of the creating process, and directories created there will also get the S_ISGID bit set. For a file that does not have the group execution bit ( S_IXGRP) set, the set-group-ID bit indicates mandatory file\/record locking. The sticky bit (S_ISVTX) on a directory means that a file in that directory can be renamed or deleted only by the owner of the file, by the owner of the directory, and by a privileged process.","Process Name":"lstat64","Link":"https:\/\/linux.die.net\/man\/2\/lstat64"}}]
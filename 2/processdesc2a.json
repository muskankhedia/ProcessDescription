[{"Process":{"Description":"The accept() system call is used with connection-based socket types ( SOCK_STREAM, SOCK_SEQPACKET). It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket. The newly created socket is not in the listening state. The original socket sockfd is unaffected by this call. The argument sockfd is a socket that has been created with socket(2), bound to a local address with bind(2), and is listening for connections after a listen(2). The argument addr is a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address family (see socket(2) and the respective protocol man pages). When addr is NULL, nothing is filled in; in this case, addrlen is not used, and should also be NULL. The addrlen argument is a value-result argument: the caller must initialize it to contain the size (in bytes) of the structure pointed to by addr; on return it will contain the actual size of the peer address. The returned address is truncated if the buffer provided is too small; in this case, addrlen will return a value greater than was supplied to the call. If no pending connections are present on the queue, and the socket is not marked as nonblocking, accept() blocks the caller until a connection is present. If the socket is marked nonblocking and no pending connections are present on the queue, accept() fails with the error EAGAIN or EWOULDBLOCK. In order to be notified of incoming connections on a socket, you can use select(2) or poll(2). A readable event will be delivered when a new connection is attempted and you may then call accept() to get a socket for that connection. Alternatively, you can set the socket to deliver SIGIO when activity occurs on a socket; see socket(7) for details. For certain protocols which require an explicit confirmation, such as DECNet, accept() can be thought of as merely dequeuing the next connection request and not implying confirmation. Confirmation can be implied by a normal read or write on the new file descriptor, and rejection can be implied by closing the new socket. Currently only DECNet has these semantics on Linux. If flags is 0, then accept4() is the same as accept(). The following values can be bitwise ORed in flags to obtain different behavior: SOCK_NONBLOCK Set the O_NONBLOCK file status flag on the new open file description. Using this flag saves extra calls to fcntl(2) to achieve the same result. SOCK_CLOEXEC Set the close-on-exec ( FD_CLOEXEC) flag on the new file descriptor. See the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful.","Process Name":"accept","Link":"https:\/\/linux.die.net\/man\/2\/accept"}},{"Process":{"Description":"The accept() system call is used with connection-based socket types ( SOCK_STREAM, SOCK_SEQPACKET). It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket. The newly created socket is not in the listening state. The original socket sockfd is unaffected by this call. The argument sockfd is a socket that has been created with socket(2), bound to a local address with bind(2), and is listening for connections after a listen(2). The argument addr is a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer. The exact format of the address returned addr is determined by the socket's address family (see socket(2) and the respective protocol man pages). When addr is NULL, nothing is filled in; in this case, addrlen is not used, and should also be NULL. The addrlen argument is a value-result argument: the caller must initialize it to contain the size (in bytes) of the structure pointed to by addr; on return it will contain the actual size of the peer address. The returned address is truncated if the buffer provided is too small; in this case, addrlen will return a value greater than was supplied to the call. If no pending connections are present on the queue, and the socket is not marked as nonblocking, accept() blocks the caller until a connection is present. If the socket is marked nonblocking and no pending connections are present on the queue, accept() fails with the error EAGAIN or EWOULDBLOCK. In order to be notified of incoming connections on a socket, you can use select(2) or poll(2). A readable event will be delivered when a new connection is attempted and you may then call accept() to get a socket for that connection. Alternatively, you can set the socket to deliver SIGIO when activity occurs on a socket; see socket(7) for details. For certain protocols which require an explicit confirmation, such as DECNet, accept() can be thought of as merely dequeuing the next connection request and not implying confirmation. Confirmation can be implied by a normal read or write on the new file descriptor, and rejection can be implied by closing the new socket. Currently only DECNet has these semantics on Linux. If flags is 0, then accept4() is the same as accept(). The following values can be bitwise ORed in flags to obtain different behavior: SOCK_NONBLOCK Set the O_NONBLOCK file status flag on the new open file description. Using this flag saves extra calls to fcntl(2) to achieve the same result. SOCK_CLOEXEC Set the close-on-exec ( FD_CLOEXEC) flag on the new file descriptor. See the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful.","Process Name":"accept4","Link":"https:\/\/linux.die.net\/man\/2\/accept4"}},{"Process":{"Description":"access() checks whether the calling process can access the file pathname. If pathname is a symbolic link, it is dereferenced. The mode specifies the accessibility check(s) to be performed, and is either the value F_OK, or a mask consisting of the bitwise OR of one or more of R_OK, W_OK, and X_OK. F_OK tests for the existence of the file. R_OK, W_OK, and X_OK test whether the file exists and grants read, write, and execute permissions, respectively. The check is done using the calling process's real UID and GID, rather than the effective IDs as is done when actually attempting an operation (e.g., open(2)) on the file. This allows set-user-ID programs to easily determine the invoking user's authority. If the calling process is privileged (i.e., its real UID is zero), then an X_OK check is successful for a regular file if execute permission is enabled for any of the file owner, group, or other.","Process Name":"access","Link":"https:\/\/linux.die.net\/man\/2\/access"}},{"Process":{"Description":"The acct() system call enables or disables process accounting. If called with the name of an existing file as its argument, accounting is turned on, and records for each terminating process are appended to filename as it terminates. An argument of NULL causes accounting to be turned off.","Process Name":"acct","Link":"https:\/\/linux.die.net\/man\/2\/acct"}},{"Process":{"Description":"add_key() asks the kernel to create or update a key of the given type and description, instantiate it with the payload of length plen, and to attach it to the nominated keyring and to return its serial number. The key type may reject the data if it's in the wrong format or in some other way invalid. If the destination keyring already contains a key that matches the specified type and description then, if the key type supports it, that key will be updated rather than a new key being created; if not, a new key will be created and it will displace the link to the extant key from the keyring. The destination keyring serial number may be that of a valid keyring to which the caller has write permission, or it may be a special keyring ID: KEY_SPEC_THREAD_KEYRING This specifies the caller's thread-specific keyring. KEY_SPEC_PROCESS_KEYRING This specifies the caller's process-specific keyring. KEY_SPEC_SESSION_KEYRING This specifies the caller's session-specific keyring. KEY_SPEC_USER_KEYRING This specifies the caller's UID-specific keyring. KEY_SPEC_USER_SESSION_KEYRING This specifies the caller's UID-session keyring.","Process Name":"add_key","Link":"https:\/\/linux.die.net\/man\/2\/add_key"}},{"Process":{"Description":"Linux uses David L. Mills' clock adjustment algorithm (see RFC 1305). The system call adjtimex() reads and optionally sets adjustment parameters for this algorithm. It takes a pointer to a timex structure, updates kernel parameters from field values, and returns the same structure with current kernel values. This structure is declared as follows: struct timex {\n    int modes;           \/* mode selector *\/\n    long offset;         \/* time offset (usec) *\/\n    long freq;           \/* frequency offset (scaled ppm) *\/\n    long maxerror;       \/* maximum error (usec) *\/\n    long esterror;       \/* estimated error (usec) *\/\n    int status;          \/* clock command\/status *\/\n    long constant;       \/* pll time constant *\/\n    long precision;      \/* clock precision (usec) (read-only) *\/\n    long tolerance;      \/* clock frequency tolerance (ppm)\n                            (read-only) *\/\n    struct timeval time; \/* current time (read-only) *\/\n    long tick;           \/* usecs between clock ticks *\/\n}; The modes field determines which parameters, if any, to set. It may contain a bitwise- or combination of zero or more of the following bits: #define ADJ_OFFSET            0x0001 \/* time offset *\/\n#define ADJ_FREQUENCY         0x0002 \/* frequency offset *\/\n#define ADJ_MAXERROR          0x0004 \/* maximum time error *\/\n#define ADJ_ESTERROR          0x0008 \/* estimated time error *\/\n#define ADJ_STATUS            0x0010 \/* clock status *\/\n#define ADJ_TIMECONST         0x0020 \/* pll time constant *\/\n#define ADJ_TICK              0x4000 \/* tick value *\/\n#define ADJ_OFFSET_SINGLESHOT 0x8001 \/* old-fashioned adjtime() *\/ Ordinary users are restricted to a zero value for mode. Only the superuser may set any parameters.","Process Name":"adjtimex","Link":"https:\/\/linux.die.net\/man\/2\/adjtimex"}},{"Process":{"Description":"These system calls are not implemented in the Linux kernel.","Process Name":"afs_syscall","Link":"https:\/\/linux.die.net\/man\/2\/afs_syscall"}},{"Process":{"Description":"alarm() arranges for a SIGALRM signal to be delivered to the calling process in seconds seconds. If seconds is zero, no new alarm() is scheduled. In any event any previously set alarm() is canceled.","Process Name":"alarm","Link":"https:\/\/linux.die.net\/man\/2\/alarm"}},{"Process":{"Description":"The system calls alloc_hugepages() and free_hugepages() were introduced in Linux 2.5.36 and removed again in 2.5.54. They existed only on i386 and ia64 (when built with CONFIG_HUGETLB_PAGE). In Linux 2.4.20 the syscall numbers exist, but the calls fail with the error ENOSYS. On i386 the memory management hardware knows about ordinary pages (4 KiB) and huge pages (2 or 4 MiB). Similarly ia64 knows about huge pages of several sizes. These system calls serve to map huge pages into the process's memory or to free them again. Huge pages are locked into memory, and are not swapped. The key argument is an identifier. When zero the pages are private, and not inherited by children. When positive the pages are shared with other applications using the same key, and inherited by child processes. The addr argument of free_hugepages() tells which page is being freed: it was the return value of a call to alloc_hugepages(). (The memory is first actually freed when all users have released it.) The addr argument of alloc_hugepages() is a hint, that the kernel may or may not follow. Addresses must be properly aligned. The len argument is the length of the required segment. It must be a multiple of the huge page size. The prot argument specifies the memory protection of the segment. It is one of PROT_READ, PROT_WRITE, PROT_EXEC. The flag argument is ignored, unless key is positive. In that case, if flag is IPC_CREAT, then a new huge page segment is created when none with the given key existed. If this flag is not set, then ENOENT is returned when no segment with the given key exists.","Process Name":"alloc_hugepages","Link":"https:\/\/linux.die.net\/man\/2\/alloc_hugepages"}},{"Process":{"Description":"The arch_prctl() function sets architecture-specific process or thread state. code selects a subfunction and passes argument addr to it; addr is interpreted as either an unsigned long for the \"set\" operations, or as an unsigned long *, for the \"get\" operations. Sub functions for x86-64 are: ARCH_SET_FS Set the 64-bit base for the FS register to addr. ARCH_GET_FS Return the 64-bit base value for the FS register of the current thread in the unsigned long pointed to by addr. ARCH_SET_GS Set the 64-bit base for the GS register to addr. ARCH_GET_GS Return the 64-bit base value for the GS register of the current thread in the unsigned long pointed to by addr.","Process Name":"arch_prctl","Link":"https:\/\/linux.die.net\/man\/2\/arch_prctl"}},{"Process":{"Description":"Programs can use posix_fadvise() to announce an intention to access file data in a specific pattern in the future, thus allowing the kernel to perform appropriate optimizations. The advice applies to a (not necessarily existent) region starting at offset and extending for len bytes (or until the end of the file if len is 0) within the file referred to by fd. The advice is not binding; it merely constitutes an expectation on behalf of the application. Permissible values for advice include: POSIX_FADV_NORMAL Indicates that the application has no advice to give about its access pattern for the specified data. If no advice is given for an open file, this is the default assumption. POSIX_FADV_SEQUENTIAL The application expects to access the specified data sequentially (with lower offsets read before higher ones). POSIX_FADV_RANDOM The specified data will be accessed in random order. POSIX_FADV_NOREUSE The specified data will be accessed only once. POSIX_FADV_WILLNEED The specified data will be accessed in the near future. POSIX_FADV_DONTNEED The specified data will not be accessed in the near future.","Process Name":"arm_fadvise","Link":"https:\/\/linux.die.net\/man\/2\/arm_fadvise"}},{"Process":{"Description":"Programs can use posix_fadvise() to announce an intention to access file data in a specific pattern in the future, thus allowing the kernel to perform appropriate optimizations. The advice applies to a (not necessarily existent) region starting at offset and extending for len bytes (or until the end of the file if len is 0) within the file referred to by fd. The advice is not binding; it merely constitutes an expectation on behalf of the application. Permissible values for advice include: POSIX_FADV_NORMAL Indicates that the application has no advice to give about its access pattern for the specified data. If no advice is given for an open file, this is the default assumption. POSIX_FADV_SEQUENTIAL The application expects to access the specified data sequentially (with lower offsets read before higher ones). POSIX_FADV_RANDOM The specified data will be accessed in random order. POSIX_FADV_NOREUSE The specified data will be accessed only once. POSIX_FADV_WILLNEED The specified data will be accessed in the near future. POSIX_FADV_DONTNEED The specified data will not be accessed in the near future.","Process Name":"arm_fadvise64_64","Link":"https:\/\/linux.die.net\/man\/2\/arm_fadvise64_64"}},{"Process":{"Description":"sync_file_range() permits fine control when synchronizing the open file referred to by the file descriptor fd with disk. offset is the starting byte of the file range to be synchronized. nbytes specifies the length of the range to be synchronized, in bytes; if nbytes is zero, then all bytes from offset through to the end of file are synchronized. Synchronization is in units of the system page size: offset is rounded down to a page boundary; (offset+nbytes-1) is rounded up to a page boundary. The flags bit-mask argument can include any of the following values: SYNC_FILE_RANGE_WAIT_BEFORE Wait upon write-out of all pages in the specified range that have already been submitted to the device driver for write-out before performing any write. SYNC_FILE_RANGE_WRITE Initiate write-out of all dirty pages in the specified range which are not presently submitted write-out. Note that even this may block if you attempt to write more than request queue size. SYNC_FILE_RANGE_WAIT_AFTER Wait upon write-out of all pages in the range after performing any write. Specifying flags as 0 is permitted, as a no-op. Warning This system call is extremely dangerous and should not be used in portable programs. None of these operations writes out the file's metadata. Therefore, unless the application is strictly performing overwrites of already-instantiated disk blocks, there are no guarantees that the data will be available after a crash. There is no user interface to know if a write is purely an overwrite. On file systems using copy-on-write semantics (e.g., btrfs) an overwrite of existing allocated blocks is impossible. When writing into preallocated space, many file systems also require calls into the block allocator, which this system call does not sync out to disk. This system call does not flush disk write caches and thus does not provide any data integrity on systems with volatile disk write caches. Some details SYNC_FILE_RANGE_WAIT_BEFORE and SYNC_FILE_RANGE_WAIT_AFTER will detect any I\/O errors or ENOSPC conditions and will return these to the caller. Useful combinations of the flags bits are: SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE Ensures that all pages in the specified range which were dirty when sync_file_range() was called are placed under write-out. This is a start-write-for-data-integrity operation. SYNC_FILE_RANGE_WRITE Start write-out of all dirty pages in the specified range which are not presently under write-out. This is an asynchronous flush-to-disk operation. This is not suitable for data integrity operations. SYNC_FILE_RANGE_WAIT_BEFORE (or SYNC_FILE_RANGE_WAIT_AFTER) Wait for completion of write-out of all pages in the specified range. This can be used after an earlier SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE operation to wait for completion of that operation, and obtain its result. SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER This is a write-for-data-integrity operation that will ensure that all pages in the specified range which were dirty when sync_file_range() was called are committed to disk.","Process Name":"arm_sync_file_range","Link":"https:\/\/linux.die.net\/man\/2\/arm_sync_file_range"}},{"Process":{"Description":"A LAM process that calls kenter(2) must call kexit() to terminate. kexit() calls all registered LAM exit functions before informing the local daemon of its death. _kexit() may be used instead of kexit() to avoid calling the exit functions. The argument to kexit() and _kexit() is an exit code which is sent in a message to the parent process, if requested by the parent process when the process was created. See rploadgo(2) and rpwait(2). By convention the exit code is 0 if the process successfully completed. An exit function is registered by calling atkexit(). The arguments passed to atkexit() are the address of the exit function to be called upon kexit(), and an argument to pass to the exit function when it is called. (Note that the function may ignore the argument, reverting to the ANSI standard C library atexit(3) behavior, where no argument is passable.) There is a limit on how many exit functions may be registered. Exit functions are called in reverse order of their registration. Some system modules register their own cleanup functions. kexit() eventually calls kdetach(2) to gracefully detach from the LAM daemon and exit(3) to actually terminate within the host operating system.","Process Name":"atkexit","Link":"https:\/\/linux.die.net\/man\/2\/atkexit"}}]
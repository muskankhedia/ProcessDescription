[{"Process":{"Description":null,"Process Name":"madvise","Link":"https:\/\/linux.die.net\/man\/2\/madvise"}},{"Process":{"Description":"These system calls are not implemented in the Linux kernel.","Process Name":"madvise1","Link":"https:\/\/linux.die.net\/man\/2\/madvise1"}},{"Process":{"Description":null,"Process Name":"mbind","Link":"https:\/\/linux.die.net\/man\/2\/mbind"}},{"Process":{"Description":"migrate_pages() attempts to move all pages of the process pid that are in memory nodes old_nodes to the memory nodes in new_nodes. Pages not located in any node in old_nodes will not be migrated. As far as possible, the kernel maintains the relative topology relationship inside old_nodes during the migration to new_nodes. The old_nodes and new_nodes arguments are pointers to bit masks of node numbers, with up to maxnode bits in each mask. These masks are maintained as arrays of unsigned long integers (in the last long integer, the bits beyond those specified by maxnode are ignored). The maxnode argument is the maximum node number in the bit mask plus one (this is the same as in mbind(2), but different from select(2)). The pid argument is the ID of the process whose pages are to be moved. To move pages in another process, the caller must be privileged (CAP_SYS_NICE) or the real or effective user ID of the calling process must match the real or saved-set user ID of the target process. If pid is 0, then migrate_pages() moves pages of the calling process. Pages shared with another process will only be moved if the initiating process has the CAP_SYS_NICE privilege.","Process Name":"migrate_pages","Link":"https:\/\/linux.die.net\/man\/2\/migrate_pages"}},{"Process":{"Description":null,"Process Name":"mincore","Link":"https:\/\/linux.die.net\/man\/2\/mincore"}},{"Process":{"Description":null,"Process Name":"mkdir","Link":"https:\/\/linux.die.net\/man\/2\/mkdir"}},{"Process":{"Description":null,"Process Name":"mkdirat","Link":"https:\/\/linux.die.net\/man\/2\/mkdirat"}},{"Process":{"Description":"The system call mknod() creates a file system node (file, device special file or named pipe) named pathname, with attributes specified by mode and dev. The mode argument specifies both the permissions to use and the type of node to be created. It should be a combination (using bitwise OR) of one of the file types listed below and the permissions for the new node. The permissions are modified by the process's umask in the usual way: the permissions of the created node are (mode & ~umask). The file type must be one of S_IFREG, S_IFCHR, S_IFBLK, S_IFIFO or S_IFSOCK to specify a regular file (which will be created empty), character special file, block special file, FIFO (named pipe), or UNIX domain socket, respectively. (Zero file type is equivalent to type S_IFREG.) If the file type is S_IFCHR or S_IFBLK then dev specifies the major and minor numbers of the newly created device special file (makedev(3) may be useful to build the value for dev); otherwise it is ignored. If pathname already exists, or is a symbolic link, this call fails with an EEXIST error. The newly created node will be owned by the effective user ID of the process. If the directory containing the node has the set-group-ID bit set, or if the file system is mounted with BSD group semantics, the new node will inherit the group ownership from its parent directory; otherwise it will be owned by the effective group ID of the process.","Process Name":"mknod","Link":"https:\/\/linux.die.net\/man\/2\/mknod"}},{"Process":{"Description":null,"Process Name":"mknodat","Link":"https:\/\/linux.die.net\/man\/2\/mknodat"}},{"Process":{"Description":"mlock() and mlockall() respectively lock part or all of the calling process's virtual address space into RAM, preventing that memory from being paged to the swap area. munlock() and munlockall() perform the converse operation, respectively unlocking part or all of the calling process's virtual address space, so that pages in the specified virtual address range may once more to be swapped out if required by the kernel memory manager. Memory locking and unlocking are performed in units of whole pages. mlock() and munlock() mlock() locks pages in the address range starting at addr and continuing for len bytes. All pages that contain a part of the specified address range are guaranteed to be resident in RAM when the call returns successfully; the pages are guaranteed to stay in RAM until later unlocked. munlock() unlocks pages in the address range starting at addr and continuing for len bytes. After this call, all pages that contain a part of the specified memory range can be moved to external swap space again by the kernel. mlockall() and munlockall() mlockall() locks all pages mapped into the address space of the calling process. This includes the pages of the code, data and stack segment, as well as shared libraries, user space kernel data, shared memory, and memory-mapped files. All mapped pages are guaranteed to be resident in RAM when the call returns successfully; the pages are guaranteed to stay in RAM until later unlocked. The flags argument is constructed as the bitwise OR of one or more of the following constants: MCL_CURRENT Lock all pages which are currently mapped into the address space of the process. MCL_FUTURE Lock all pages which will become mapped into the address space of the process in the future. These could be for instance new pages required by a growing heap and stack as well as new memory mapped files or shared memory regions. If MCL_FUTURE has been specified, then a later system call (e.g., mmap(2), sbrk(2), malloc(3)), may fail if it would cause the number of locked bytes to exceed the permitted maximum (see below). In the same circumstances, stack growth may likewise fail: the kernel will deny stack expansion and deliver a SIGSEGV signal to the process. munlockall() unlocks all pages mapped into the address space of the calling process.","Process Name":"mlock","Link":"https:\/\/linux.die.net\/man\/2\/mlock"}},{"Process":{"Description":null,"Process Name":"mlockall","Link":"https:\/\/linux.die.net\/man\/2\/mlockall"}},{"Process":{"Description":"mmap() creates a new mapping in the virtual address space of the calling process. The starting address for the new mapping is specified in addr. The length argument specifies the length of the mapping. If addr is NULL, then the kernel chooses the address at which to create the mapping; this is the most portable method of creating a new mapping. If addr is not NULL, then the kernel takes it as a hint about where to place the mapping; on Linux, the mapping will be created at a nearby page boundary. The address of the new mapping is returned as the result of the call. The contents of a file mapping (as opposed to an anonymous mapping; see MAP_ANONYMOUS below), are initialized using length bytes starting at offset offset in the file (or other object) referred to by the file descriptor fd. offset must be a multiple of the page size as returned by sysconf(_SC_PAGE_SIZE). The prot argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file). It is either PROT_NONE or the bitwise OR of one or more of the following flags: PROT_EXEC Pages may be executed. PROT_READ Pages may be read. PROT_WRITE Pages may be written. PROT_NONE Pages may not be accessed. The flags argument determines whether updates to the mapping are visible to other processes mapping the same region, and whether updates are carried through to the underlying file. This behavior is determined by including exactly one of the following values in flags: MAP_SHARED Share this mapping. Updates to the mapping are visible to other processes that map this file, and are carried through to the underlying file. The file may not actually be updated until msync(2) or munmap() is called. MAP_PRIVATE Create a private copy-on-write mapping. Updates to the mapping are not visible to other processes mapping the same file, and are not carried through to the underlying file. It is unspecified whether changes made to the file after the mmap() call are visible in the mapped region. Both of these flags are described in POSIX.1-2001. In addition, zero or more of the following values can be ORed in flags: MAP_32BIT (since Linux 2.4.20, 2.6) Put the mapping into the first 2 Gigabytes of the process address space. This flag is only supported on x86-64, for 64-bit programs. It was added to allow thread stacks to be allocated somewhere in the first 2GB of memory, so as to improve context-switch performance on some early 64-bit processors. Modern x86-64 processors no longer have this performance problem, so use of this flag is not required on those systems. The MAP_32BIT flag is ignored when MAP_FIXED is set. MAP_ANON Synonym for MAP_ANONYMOUS. Deprecated. MAP_ANONYMOUS The mapping is not backed by any file; its contents are initialized to zero. The fd and offset arguments are ignored; however, some implementations require fd to be -1 if MAP_ANONYMOUS (or MAP_ANON) is specified, and portable applications should ensure this. The use of MAP_ANONYMOUS in conjunction with MAP_SHARED is only supported on Linux since kernel 2.4. MAP_DENYWRITE This flag is ignored. (Long ago, it signaled that attempts to write to the underlying file should fail with ETXTBUSY. But this was a source of denial-of-service attacks.) MAP_EXECUTABLE This flag is ignored. MAP_FILE Compatibility flag. Ignored. MAP_FIXED Don't interpret addr as a hint: place the mapping at exactly that address. addr must be a multiple of the page size. If the memory region specified by addr and len overlaps pages of any existing mapping(s), then the overlapped part of the existing mapping(s) will be discarded. If the specified address cannot be used, mmap() will fail. Because requiring a fixed address for a mapping is less portable, the use of this option is discouraged. MAP_GROWSDOWN Used for stacks. Indicates to the kernel virtual memory system that the mapping should extend downward in memory. MAP_HUGETLB (since Linux 2.6.32) Allocate the mapping using \"huge pages.\" See the Linux kernel source file Documentation\/vm\/hugetlbpage.txt for further information. MAP_LOCKED (since Linux 2.5.37) Lock the pages of the mapped region into memory in the manner of mlock(2). This flag is ignored in older kernels. MAP_NONBLOCK (since Linux 2.5.46) Only meaningful in conjunction with MAP_POPULATE. Don't perform read-ahead: only create page tables entries for pages that are already present in RAM. Since Linux 2.6.23, this flag causes MAP_POPULATE to do nothing. One day the combination of MAP_POPULATE and MAP_NONBLOCK may be reimplemented. MAP_NORESERVE Do not reserve swap space for this mapping. When swap space is reserved, one has the guarantee that it is possible to modify the mapping. When swap space is not reserved one might get SIGSEGV upon a write if no physical memory is available. See also the discussion of the file \/proc\/sys\/vm\/overcommit_memory in proc(5). In kernels before 2.6, this flag only had effect for private writable mappings. MAP_POPULATE (since Linux 2.5.46) Populate (prefault) page tables for a mapping. For a file mapping, this causes read-ahead on the file. Later accesses to the mapping will not be blocked by page faults. MAP_POPULATE is only supported for private mappings since Linux 2.6.23. MAP_STACK (since Linux 2.6.27) Allocate the mapping at an address suitable for a process or thread stack. This flag is currently a no-op, but is used in the glibc threading implementation so that if some architectures require special treatment for stack allocations, support can later be transparently implemented for glibc. MAP_UNINITIALIZED (since Linux 2.6.33) Don't clear anonymous pages. This flag is intended to improve performance on embedded devices. This flag is only honored if the kernel was configured with the CONFIG_MMAP_ALLOW_UNINITIALIZED option. Because of the security implications, that option is normally enabled only on embedded devices (i.e., devices where one has complete control of the contents of user memory). Of the above flags, only MAP_FIXED is specified in POSIX.1-2001. However, most systems also support MAP_ANONYMOUS (or its synonym MAP_ANON). Some systems document the additional flags MAP_AUTOGROW, MAP_AUTORESRV, MAP_COPY, and MAP_LOCAL. Memory mapped by mmap() is preserved across fork(2), with the same attributes. A file is mapped in multiples of the page size. For a file that is not a multiple of the page size, the remaining memory is zeroed when mapped, and writes to that region are not written out to the file. The effect of changing the size of the underlying file of a mapping on the pages that correspond to added or removed regions of the file is unspecified. munmap() The munmap() system call deletes the mappings for the specified address range, and causes further references to addresses within the range to generate invalid memory references. The region is also automatically unmapped when the process is terminated. On the other hand, closing the file descriptor does not unmap the region. The address addr must be a multiple of the page size. All pages containing a part of the indicated range are unmapped, and subsequent references to these pages will generate SIGSEGV. It is not an error if the indicated range does not contain any mapped pages. Timestamps changes for file-backed mappings For file-backed mappings, the st_atime field for the mapped file may be updated at any time between the mmap() and the corresponding unmapping; the first reference to a mapped page will update the field if it has not been already. The st_ctime and st_mtime field for a file mapped with PROT_WRITE and MAP_SHARED will be updated after a write to the mapped region, and before a subsequent msync(2) with the MS_SYNC or MS_ASYNC flag, if one occurs.","Process Name":"mmap","Link":"https:\/\/linux.die.net\/man\/2\/mmap"}},{"Process":{"Description":null,"Process Name":"mmap2","Link":"https:\/\/linux.die.net\/man\/2\/mmap2"}},{"Process":{"Description":null,"Process Name":"modify_ldt","Link":"https:\/\/linux.die.net\/man\/2\/modify_ldt"}},{"Process":{"Description":null,"Process Name":"mount","Link":"https:\/\/linux.die.net\/man\/2\/mount"}},{"Process":{"Description":"move_pages() moves the specified pages of the process pid to the memory nodes specified by nodes. The result of the move is reflected in status. The flags indicate constraints on the pages to be moved. pid is the ID of the process in which pages are to be moved. To move pages in another process, the caller must be privileged (CAP_SYS_NICE) or the real or effective user ID of the calling process must match the real or saved-set user ID of the target process. If pid is 0, then move_pages() moves pages of the calling process. count is the number of pages to move. It defines the size of the three arrays pages, nodes, and status. pages is an array of pointers to the pages that should be moved. These are pointers that should be aligned to page boundaries. Addresses are specified as seen by the process specified by pid. nodes is an array of integers that specify the desired location for each page. Each element in the array is a node number. nodes can also be NULL, in which case move_pages() does not move any pages but instead will return the node where each page currently resides, in the status array. Obtaining the status of each page may be necessary to determine pages that need to be moved. status is an array of integers that return the status of each page. The array only contains valid values if move_pages() did not return an error. flags specify what types of pages to move. MPOL_MF_MOVE means that only pages that are in exclusive use by the process are to be moved. MPOL_MF_MOVE_ALL means that pages shared between multiple processes can also be moved. The process must be privileged (CAP_SYS_NICE) to use MPOL_MF_MOVE_ALL.","Process Name":"move_pages","Link":"https:\/\/linux.die.net\/man\/2\/move_pages"}},{"Process":{"Description":null,"Process Name":"mprotect","Link":"https:\/\/linux.die.net\/man\/2\/mprotect"}},{"Process":{"Description":"These system calls are not implemented in the Linux kernel.","Process Name":"mpx","Link":"https:\/\/linux.die.net\/man\/2\/mpx"}},{"Process":{"Description":null,"Process Name":"mq_getsetattr","Link":"https:\/\/linux.die.net\/man\/2\/mq_getsetattr"}},{"Process":{"Description":"mq_notify() allows the calling process to register or unregister for delivery of an asynchronous notification when a new message arrives on the empty message queue referred to by the descriptor mqdes. The sevp argument is a pointer to a sigevent structure. For the definition and general details of this structure, see sigevent(7). If sevp is a non-NULL pointer, then mq_notify() registers the calling process to receive message notification. The sigev_notify field of the sigevent structure to which sevp points specifies how notification is to be performed. This field has one of the following values: SIGEV_NONE A \"null\" notification: the calling process is registered as the target for notification, but when a message arrives, no notification is sent. SIGEV_SIGNAL Notify the process by sending the signal specified in sigev_signo. See sigevent(7) for general details. The si_code field of the siginfo_t structure will be set to SI_MESGQ. In addition, si_pid will be set to the PID of the process that sent the message, and si_uid will be set to the real user ID of the sending process. SIGEV_THREAD Upon message delivery, invoke sigev_notify_function as if it were the start function of a new thread. See sigevent(7) for details. Only one process can be registered to receive notification from a message queue. If sevp is NULL, and the calling process is currently registered to receive notifications for this message queue, then the registration is removed; another process can then register to receive a message notification for this queue. Message notification only occurs when a new message arrives and the queue was previously empty. If the queue was not empty at the time mq_notify() was called, then a notification will only occur after the queue is emptied and a new message arrives. If another process or thread is waiting to read a message from an empty queue using mq_receive(3), then any message notification registration is ignored: the message is delivered to the process or thread calling mq_receive(3), and the message notification registration remains in effect. Notification occurs once: after a notification is delivered, the notification registration is removed, and another process can register for message notification. If the notified process wishes to receive the next notification, it can use mq_notify() to request a further notification. This should be done before emptying all unread messages from the queue. (Placing the queue in nonblocking mode is useful for emptying the queue of messages without blocking once it is empty.)","Process Name":"mq_notify","Link":"https:\/\/linux.die.net\/man\/2\/mq_notify"}},{"Process":{"Description":null,"Process Name":"mq_open","Link":"https:\/\/linux.die.net\/man\/2\/mq_open"}},{"Process":{"Description":"mq_receive() removes the oldest message with the highest priority from the message queue referred to by the descriptor mqdes, and places it in the buffer pointed to by msg_ptr. The msg_len argument specifies the size of the buffer pointed to by msg_ptr; this must be greater than the mq_msgsize attribute of the queue (see mq_getattr(3)). If msg_prio is not NULL, then the buffer to which it points is used to return the priority associated with the received message. If the queue is empty, then, by default, mq_receive() blocks until a message becomes available, or the call is interrupted by a signal handler. If the O_NONBLOCK flag is enabled for the message queue description, then the call instead fails immediately with the error EAGAIN. mq_timedreceive() behaves just like mq_receive(), except that if the queue is empty and the O_NONBLOCK flag is not enabled for the message queue description, then abs_timeout points to a structure which specifies a ceiling on the time for which the call will block. This ceiling is an absolute timeout in seconds and nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC), and it is specified in the following structure: struct timespec {\n    time_t tv_sec;        \/* seconds *\/\n    long   tv_nsec;       \/* nanoseconds *\/\n}; If no message is available, and the timeout has already expired by the time of the call, mq_timedreceive() returns immediately.","Process Name":"mq_timedreceive","Link":"https:\/\/linux.die.net\/man\/2\/mq_timedreceive"}},{"Process":{"Description":null,"Process Name":"mq_timedsend","Link":"https:\/\/linux.die.net\/man\/2\/mq_timedsend"}},{"Process":{"Description":"mq_unlink() removes the specified message queue name. The message queue name is removed immediately. The queue itself is destroyed once any other processes that have the queue open close their descriptors referring to the queue.","Process Name":"mq_unlink","Link":"https:\/\/linux.die.net\/man\/2\/mq_unlink"}},{"Process":{"Description":null,"Process Name":"mremap","Link":"https:\/\/linux.die.net\/man\/2\/mremap"}},{"Process":{"Description":null,"Process Name":"msgctl","Link":"https:\/\/linux.die.net\/man\/2\/msgctl"}},{"Process":{"Description":null,"Process Name":"msgget","Link":"https:\/\/linux.die.net\/man\/2\/msgget"}},{"Process":{"Description":"The msgsnd() and msgrcv() system calls are used, respectively, to send messages to, and receive messages from, a message queue. The calling process must have write permission on the message queue in order to send a message, and read permission to receive a message. The msgp argument is a pointer to caller-defined structure of the following general form: struct msgbuf {\n    long mtype;       \/* message type, must be > 0 *\/\n    char mtext[1];    \/* message data *\/\n}; The mtext field is an array (or other structure) whose size is specified by msgsz, a nonnegative integer value. Messages of zero length (i.e., no mtext field) are permitted. The mtype field must have a strictly positive integer value. This value can be used by the receiving process for message selection (see the description of msgrcv() below). msgsnd() The msgsnd() system call appends a copy of the message pointed to by msgp to the message queue whose identifier is specified by msqid. If sufficient space is available in the queue, msgsnd() succeeds immediately. (The queue capacity is defined by the msg_qbytes field in the associated data structure for the message queue. During queue creation this field is initialized to MSGMNB bytes, but this limit can be modified using msgctl(2).) If insufficient space is available in the queue, then the default behavior of msgsnd() is to block until space becomes available. If IPC_NOWAIT is specified in msgflg, then the call instead fails with the error EAGAIN. A blocked msgsnd() call may also fail if: * the queue is removed, in which case the system call fails with errno set to EIDRM; or * a signal is caught, in which case the system call fails with errno set to EINTR;see signal(7). (msgsnd() is never automatically restarted after being interrupted by a signal handler, regardless of the setting of the SA_RESTART flag when establishing a signal handler.) Upon successful completion the message queue data structure is updated as follows: msg_lspid is set to the process ID of the calling process. msg_qnum is incremented by 1. msg_stime is set to the current time. msgrcv() The msgrcv() system call removes a message from the queue specified by msqid and places it in the buffer pointed to by msgp. The argument msgsz specifies the maximum size in bytes for the member mtext of the structure pointed to by the msgp argument. If the message text has length greater than msgsz, then the behavior depends on whether MSG_NOERROR is specified in msgflg. If MSG_NOERROR is specified, then the message text will be truncated (and the truncated part will be lost); if MSG_NOERROR is not specified, then the message isn't removed from the queue and the system call fails returning -1 with errno set to E2BIG. The argument msgtyp specifies the type of message requested as follows: * If msgtyp is 0, then the first message in the queue is read. * If msgtyp is greater than 0, then the first message in the queue of type msgtyp is read, unless MSG_EXCEPT was specified in msgflg, in which case the first message in the queue of type not equal to msgtyp will be read. * If msgtyp is less than 0, then the first message in the queue with the lowest type less than or equal to the absolute value of msgtyp will be read. The msgflg argument is a bit mask constructed by ORing together zero or more of the following flags: IPC_NOWAIT Return immediately if no message of the requested type is in the queue. The system call fails with errno set to ENOMSG. MSG_EXCEPT Used with msgtyp greater than 0 to read the first message in the queue with message type that differs from msgtyp. MSG_NOERROR To truncate the message text if longer than msgsz bytes. If no message of the requested type is available and IPC_NOWAIT isn't specified in msgflg, the calling process is blocked until one of the following conditions occurs: * A message of the desired type is placed in the queue. * The message queue is removed from the system. In this case the system call fails with errno set to EIDRM. * The calling process catches a signal. In this case the system call fails with errno set to EINTR. (msgrcv() is never automatically restarted after being interrupted by a signal handler, regardless of the setting of the SA_RESTART flag when establishing a signal handler.) Upon successful completion the message queue data structure is updated as follows: msg_lrpid is set to the process ID of the calling process. msg_qnum is decremented by 1. msg_rtime is set to the current time.","Process Name":"msgop","Link":"https:\/\/linux.die.net\/man\/2\/msgop"}},{"Process":{"Description":null,"Process Name":"msgrcv","Link":"https:\/\/linux.die.net\/man\/2\/msgrcv"}},{"Process":{"Description":"The msgsnd() and msgrcv() system calls are used, respectively, to send messages to, and receive messages from, a message queue. The calling process must have write permission on the message queue in order to send a message, and read permission to receive a message. The msgp argument is a pointer to caller-defined structure of the following general form: struct msgbuf {\n    long mtype;       \/* message type, must be > 0 *\/\n    char mtext[1];    \/* message data *\/\n}; The mtext field is an array (or other structure) whose size is specified by msgsz, a nonnegative integer value. Messages of zero length (i.e., no mtext field) are permitted. The mtype field must have a strictly positive integer value. This value can be used by the receiving process for message selection (see the description of msgrcv() below). msgsnd() The msgsnd() system call appends a copy of the message pointed to by msgp to the message queue whose identifier is specified by msqid. If sufficient space is available in the queue, msgsnd() succeeds immediately. (The queue capacity is defined by the msg_qbytes field in the associated data structure for the message queue. During queue creation this field is initialized to MSGMNB bytes, but this limit can be modified using msgctl(2).) If insufficient space is available in the queue, then the default behavior of msgsnd() is to block until space becomes available. If IPC_NOWAIT is specified in msgflg, then the call instead fails with the error EAGAIN. A blocked msgsnd() call may also fail if: * the queue is removed, in which case the system call fails with errno set to EIDRM; or * a signal is caught, in which case the system call fails with errno set to EINTR;see signal(7). (msgsnd() is never automatically restarted after being interrupted by a signal handler, regardless of the setting of the SA_RESTART flag when establishing a signal handler.) Upon successful completion the message queue data structure is updated as follows: msg_lspid is set to the process ID of the calling process. msg_qnum is incremented by 1. msg_stime is set to the current time. msgrcv() The msgrcv() system call removes a message from the queue specified by msqid and places it in the buffer pointed to by msgp. The argument msgsz specifies the maximum size in bytes for the member mtext of the structure pointed to by the msgp argument. If the message text has length greater than msgsz, then the behavior depends on whether MSG_NOERROR is specified in msgflg. If MSG_NOERROR is specified, then the message text will be truncated (and the truncated part will be lost); if MSG_NOERROR is not specified, then the message isn't removed from the queue and the system call fails returning -1 with errno set to E2BIG. The argument msgtyp specifies the type of message requested as follows: * If msgtyp is 0, then the first message in the queue is read. * If msgtyp is greater than 0, then the first message in the queue of type msgtyp is read, unless MSG_EXCEPT was specified in msgflg, in which case the first message in the queue of type not equal to msgtyp will be read. * If msgtyp is less than 0, then the first message in the queue with the lowest type less than or equal to the absolute value of msgtyp will be read. The msgflg argument is a bit mask constructed by ORing together zero or more of the following flags: IPC_NOWAIT Return immediately if no message of the requested type is in the queue. The system call fails with errno set to ENOMSG. MSG_EXCEPT Used with msgtyp greater than 0 to read the first message in the queue with message type that differs from msgtyp. MSG_NOERROR To truncate the message text if longer than msgsz bytes. If no message of the requested type is available and IPC_NOWAIT isn't specified in msgflg, the calling process is blocked until one of the following conditions occurs: * A message of the desired type is placed in the queue. * The message queue is removed from the system. In this case the system call fails with errno set to EIDRM. * The calling process catches a signal. In this case the system call fails with errno set to EINTR. (msgrcv() is never automatically restarted after being interrupted by a signal handler, regardless of the setting of the SA_RESTART flag when establishing a signal handler.) Upon successful completion the message queue data structure is updated as follows: msg_lrpid is set to the process ID of the calling process. msg_qnum is decremented by 1. msg_rtime is set to the current time.","Process Name":"msgsnd","Link":"https:\/\/linux.die.net\/man\/2\/msgsnd"}},{"Process":{"Description":null,"Process Name":"msync","Link":"https:\/\/linux.die.net\/man\/2\/msync"}},{"Process":{"Description":"These system calls are not implemented in the Linux kernel.","Process Name":"multiplexer","Link":"https:\/\/linux.die.net\/man\/2\/multiplexer"}},{"Process":{"Description":null,"Process Name":"munlock","Link":"https:\/\/linux.die.net\/man\/2\/munlock"}},{"Process":{"Description":null,"Process Name":"munlockall","Link":"https:\/\/linux.die.net\/man\/2\/munlockall"}},{"Process":{"Description":null,"Process Name":"munmap","Link":"https:\/\/linux.die.net\/man\/2\/munmap"}}]
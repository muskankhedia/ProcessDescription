[{"Process":{"Description":"Note: Since Linux 2.6, this system call is deprecated and does nothing. It is likely to disappear altogether in a future kernel release. Nowadays, the task performed by bdflush() is handled by the kernel pdflush thread. bdflush() starts, flushes, or tunes the buffer-dirty-flush daemon. Only a privileged process (one with the CAP_SYS_ADMIN capability) may call bdflush(). If func is negative or 0, and no daemon has been started, then bdflush() enters the daemon code and never returns. If func is 1, some dirty buffers are written to disk. If func is 2 or more and is even (low bit is 0), then address is the address of a long word, and the tuning parameter numbered (func-2)\/2 is returned to the caller in that address. If func is 3 or more and is odd (low bit is 1), then data is a long word, and the kernel sets tuning parameter numbered (func-3)\/2 to that value. The set of parameters, their values, and their valid ranges are defined in the Linux kernel source file fs\/buffer.c.","Process Name":"bdflush","Link":"https:\/\/linux.die.net\/man\/2\/bdflush"}},{"Process":{"Description":"When a socket is created with socket(2), it exists in a name space (address family) but has no address assigned to it. bind() assigns the address specified by addr to the socket referred to by the file descriptor sockfd. addrlen specifies the size, in bytes, of the address structure pointed to by addr. Traditionally, this operation is called \"assigning a name to a socket\". It is normally necessary to assign a local address using bind() before a SOCK_STREAM socket may receive connections (see accept(2)). The rules used in name binding vary between address families. Consult the manual entries in Section 7 for detailed information. For AF_INET see ip(7), for AF_INET6 see ipv6(7), for AF_UNIX see unix(7), for AF_APPLETALK see ddp(7), for AF_PACKET see packet(7), for AF_X25 see x25(7) and for AF_NETLINK see netlink(7). The actual structure passed for the addr argument will depend on the address family. The sockaddr structure is defined as something like: struct sockaddr {\n    sa_family_t sa_family;\n    char        sa_data[14];\n} The only purpose of this structure is to cast the structure pointer passed in addr in order to avoid compiler warnings. See EXAMPLE below.","Process Name":"bind","Link":"https:\/\/linux.die.net\/man\/2\/bind"}},{"Process":{"Description":"These system calls are not implemented in the Linux kernel.","Process Name":"break","Link":"https:\/\/linux.die.net\/man\/2\/break"}},{"Process":{"Description":"brk() and sbrk() change the location of the program break, which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment). Increasing the program break has the effect of allocating memory to the process; decreasing the break deallocates memory. brk() sets the end of the data segment to the value specified by addr, when that value is reasonable, the system has enough memory, and the process does not exceed its maximum data size (see setrlimit(2)). sbrk() increments the program's data space by increment bytes. Calling sbrk() with an increment of 0 can be used to find the current location of the program break.","Process Name":"brk","Link":"https:\/\/linux.die.net\/man\/2\/brk"}}]
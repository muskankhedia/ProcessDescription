[{"Process":{"Description":"tee() duplicates up to len bytes of data from the pipe referred to by the file descriptor fd_in to the pipe referred to by the file descriptor fd_out. It does not consume the data that is duplicated from fd_in; therefore, that data can be copied by a subsequent splice(2). flags is a series of modifier flags, which share the name space with splice(2) and vmsplice(2): SPLICE_F_MOVE Currently has no effect for tee(); see splice(2). SPLICE_F_NONBLOCK Do not block on I\/O; see splice(2) for further details. SPLICE_F_MORE Currently has no effect for tee(), but may be implemented in the future; see splice(2). SPLICE_F_GIFT Unused for tee(); see vmsplice(2).","Process Name":"tee","Link":"https:\/\/linux.die.net\/man\/2\/tee"}},{"Process":{"Description":null,"Process Name":"tgkill","Link":"https:\/\/linux.die.net\/man\/2\/tgkill"}},{"Process":{"Description":null,"Process Name":"time","Link":"https:\/\/linux.die.net\/man\/2\/time"}},{"Process":{"Description":null,"Process Name":"timer_create","Link":"https:\/\/linux.die.net\/man\/2\/timer_create"}},{"Process":{"Description":null,"Process Name":"timer_delete","Link":"https:\/\/linux.die.net\/man\/2\/timer_delete"}},{"Process":{"Description":null,"Process Name":"timer_getoverrun","Link":"https:\/\/linux.die.net\/man\/2\/timer_getoverrun"}},{"Process":{"Description":"timer_settime() arms or disarms the timer identified by timerid. The new_value argument is pointer to an itimerspec structure that specifies the new initial value and the new interval for the timer. The itimerspec structure is defined as follows: struct timespec {\n    time_t tv_sec;                \/* Seconds *\/\n    long   tv_nsec;               \/* Nanoseconds *\/\n};\n\nstruct itimerspec {\n    struct timespec it_interval;  \/* Timer interval *\/\n    struct timespec it_value;     \/* Initial expiration *\/\n}; Each of the substructures of the itimerspec structure is a timespec structure that allows a time value to be specified in seconds and nanoseconds. These time values are measured according to the clock that was specified when the timer was created by timer_create(2) If new_value->it_value specifies a nonzero value (i.e., either subfield is nonzero), then timer_settime() arms (starts) the timer, setting it to initially expire at the given time. (If the timer was already armed, then the previous settings are overwritten.) If new_value->it_value specifies a zero value (i.e., both subfields are zero), then the timer is disarmed. The new_value->it_interval field specifies the period of the timer, in seconds and nanoseconds. If this field is nonzero, then each time that an armed timer expires, the timer is reloaded from the value specified in new_value->it_interval. If new_value->it_interval specifies a zero value then the timer expires just once, at the time specified by it_value. By default, the initial expiration time specified in new_value->it_value is interpreted relative to the current time on the timer's clock at the time of the call. This can be modified by specifying TIMER_ABSTIME in flags, in which case new_value->it_value is interpreted as an absolute value as measured on the timer's clock; that is, the timer will expire when the clock value reaches the value specified by new_value->it_value. If the specified absolute time has already passed, then the timer expires immediately, and the overrun count (see timer_getoverrun(2)) will be set correctly. If the value of the CLOCK_REALTIME clock is adjusted while an absolute timer based on that clock is armed, then the expiration of the timer will be appropriately adjusted. Adjustments to the CLOCK_REALTIME clock have no effect on relative timers based on that clock. If old_value is not NULL, then it points to a buffer that is used to return the previous interval of the timer (in old_value->it_interval) and the amount of time until the timer would previously have next expired (in old_value->it_value). timer_gettime() returns the time until next expiration, and the interval, for the timer specified by timerid, in the buffer pointed to by curr_value. The time remaining until the next timer expiration is returned in curr_value->it_value; this is always a relative value, regardless of whether the TIMER_ABSTIME flag was used when arming the timer. If the value returned in curr_value->it_value is zero, then the timer is currently disarmed. The timer interval is returned in curr_value->it_interval. If the value returned in curr_value->it_interval is zero, then this is a \"one-shot\" timer.","Process Name":"timer_gettime","Link":"https:\/\/linux.die.net\/man\/2\/timer_gettime"}},{"Process":{"Description":null,"Process Name":"timer_settime","Link":"https:\/\/linux.die.net\/man\/2\/timer_settime"}},{"Process":{"Description":null,"Process Name":"timerfd_create","Link":"https:\/\/linux.die.net\/man\/2\/timerfd_create"}},{"Process":{"Description":"These system calls create and operate on a timer that delivers timer expiration notifications via a file descriptor. They provide an alternative to the use of setitimer(2) or timer_create(2), with the advantage that the file descriptor may be monitored by select(2), poll(2), and epoll(7). The use of these three system calls is analogous to the use of timer_create(2), timer_settime(2), and timer_gettime(2). (There is no analog of timer_getoverrun(2), since that functionality is provided by read(2), as described below.) timerfd_create() timerfd_create() creates a new timer object, and returns a file descriptor that refers to that timer. The clockid argument specifies the clock that is used to mark the progress of the timer, and must be either CLOCK_REALTIME or CLOCK_MONOTONIC. CLOCK_REALTIME is a settable system-wide clock. CLOCK_MONOTONIC is a nonsettable clock that is not affected by discontinuous changes in the system clock (e.g., manual changes to system time). The current value of each of these clocks can be retrieved using clock_gettime(2). Starting with Linux 2.6.27, the following values may be bitwise ORed in flags to change the behavior of timerfd_create(): TFD_NONBLOCK Set the O_NONBLOCK file status flag on the new open file description. Using this flag saves extra calls to fcntl(2) to achieve the same result. TFD_CLOEXEC Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor. See the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful. In Linux versions up to and including 2.6.26, flags must be specified as zero. timerfd_settime() timerfd_settime() arms (starts) or disarms (stops) the timer referred to by the file descriptor fd. The new_value argument specifies the initial expiration and interval for the timer. The itimer structure used for this argument contains two fields, each of which is in turn a structure of type timespec: struct timespec {\n    time_t tv_sec;                \/* Seconds *\/\n    long   tv_nsec;               \/* Nanoseconds *\/\n};\n\nstruct itimerspec {\n    struct timespec it_interval;  \/* Interval for periodic timer *\/\n    struct timespec it_value;     \/* Initial expiration *\/\n}; new_value.it_value specifies the initial expiration of the timer, in seconds and nanoseconds. Setting either field of new_value.it_value to a nonzero value arms the timer. Setting both fields of new_value.it_value to zero disarms the timer. Setting one or both fields of new_value.it_interval to nonzero values specifies the period, in seconds and nanoseconds, for repeated timer expirations after the initial expiration. If both fields of new_value.it_interval are zero, the timer expires just once, at the time specified by new_value.it_value. The flags argument is either 0, to start a relative timer (new_value.it_value specifies a time relative to the current value of the clock specified by clockid), or TFD_TIMER_ABSTIME, to start an absolute timer (new_value.it_value specifies an absolute time for the clock specified by clockid; that is, the timer will expire when the value of that clock reaches the value specified in new_value.it_value). If the old_value argument is not NULL, then the itimerspec structure that it points to is used to return the setting of the timer that was current at the time of the call; see the description of timerfd_gettime() following. timerfd_gettime() timerfd_gettime() returns, in curr_value, an itimerspec structure that contains the current setting of the timer referred to by the file descriptor fd. The it_value field returns the amount of time until the timer will next expire. If both fields of this structure are zero, then the timer is currently disarmed. This field always contains a relative value, regardless of whether the TFD_TIMER_ABSTIME flag was specified when setting the timer. The it_interval field returns the interval of the timer. If both fields of this structure are zero, then the timer is set to expire just once, at the time specified by curr_value.it_value. Operating on a timer file descriptor The file descriptor returned by timerfd_create() supports the following operations: read(2) If the timer has already expired one or more times since its settings were last modified using timerfd_settime(), or since the last successful read(2), then the buffer given to read(2) returns an unsigned 8-byte integer ( uint64_t) containing the number of expirations that have occurred. (The returned value is in host byte order, i.e., the native byte order for integers on the host machine.) If no timer expirations have occurred at the time of the read(2), then the call either blocks until the next timer expiration, or fails with the error EAGAIN if the file descriptor has been made nonblocking (via the use of the fcntl(2) F_SETFL operation to set the O_NONBLOCK flag). A read(2) will fail with the error EINVAL if the size of the supplied buffer is less than 8 bytes. poll(2), select(2) (and similar) The file descriptor is readable (the select(2) readfds argument; the poll(2) POLLIN flag) if one or more timer expirations have occurred. The file descriptor also supports the other file-descriptor multiplexing APIs: pselect(2), ppoll(2), and epoll(7). close(2) When the file descriptor is no longer required it should be closed. When all file descriptors associated with the same timer object have been closed, the timer is disarmed and its resources are freed by the kernel. fork(2) semantics After a fork(2), the child inherits a copy of the file descriptor created by timerfd_create(). The file descriptor refers to the same underlying timer object as the corresponding file descriptor in the parent, and read(2)s in the child will return information about expirations of the timer. execve(2) semantics A file descriptor created by timerfd_create() is preserved across execve(2), and continues to generate timer expirations if the timer was armed.","Process Name":"timerfd_gettime","Link":"https:\/\/linux.die.net\/man\/2\/timerfd_gettime"}},{"Process":{"Description":null,"Process Name":"timerfd_settime","Link":"https:\/\/linux.die.net\/man\/2\/timerfd_settime"}},{"Process":{"Description":null,"Process Name":"times","Link":"https:\/\/linux.die.net\/man\/2\/times"}},{"Process":{"Description":null,"Process Name":"tkill","Link":"https:\/\/linux.die.net\/man\/2\/tkill"}},{"Process":{"Description":"These transport message-passing routines add flow control to the network routines, nsend(2) and nrecv(2), and enable multiple processes to send multi-packet messages to a receiver using the same event and type while maintaining the atomicity of the messages. The sending process sends a \"ready-to-send\" message to the receiver and blocks until the receiving process signals that it is ready. The receiver returns to the sender a new event, its process ID negated, to be used in the transfer of the body of the message. The introduction of the second event allows multi-packet messages, using the same event and destined to the same node, to be received with no mixing up of packets. The transport routines are also typically used while developing and debugging applications. Naturally, they have higher overhead than their network counterparts. The transport routines overcome the basic danger of LAM network message-passing - the lack of strong synchronization. A sending process can transmit a message that may never be received due to programming error or deadlock. This message will never be dropped or timed out. Some LAM process will always be stuck with it, waiting for a synchronizing drecv(2) or nrecv(2) that will never happen. If that unfortunate process is a buffer, it can be located by the user and swept clean (see sweep(1)). However, if the process is a link proprietor, the link is henceforth plugged and useless. The transport routines solve this problem by causing the sending process to block until it receives a \"ready-to-receive\" protocol message from the receiving process. If due to a programming error there is no receiving process at the other end, the \"ready-to-send\" message is guaranteed not to plug a link proprietor. The second advantage in this case is that the sender is stopped from flooding the system with messages that no receiver will consume. After the pre-synchronizing exchange, the network routines are invoked and the message is transmitted. Use of the network message structure passed to tsend() and trecv() is the same as described under nsend(2).","Process Name":"trcv","Link":"https:\/\/linux.die.net\/man\/2\/trcv"}},{"Process":{"Description":null,"Process Name":"trecv","Link":"https:\/\/linux.die.net\/man\/2\/trecv"}},{"Process":{"Description":"The most recent error message is displayed. Many LAM subroutines have an ierror argument that returns an error code. If TRROR() is invoked immediately after detecting an error condition from a LAM subroutine, the description corresponding to the ierror code will be displayed. The error message will be preceded by the contents of strname.","Process Name":"trror","Link":"https:\/\/linux.die.net\/man\/2\/trror"}},{"Process":{"Description":null,"Process Name":"truncate","Link":"https:\/\/linux.die.net\/man\/2\/truncate"}},{"Process":{"Description":null,"Process Name":"truncate64","Link":"https:\/\/linux.die.net\/man\/2\/truncate64"}},{"Process":{"Description":null,"Process Name":"tsend","Link":"https:\/\/linux.die.net\/man\/2\/tsend"}},{"Process":{"Description":"These transport message-passing routines add flow control to the network routines, nsend(2) and nrecv(2), and enable multiple processes to send multi-packet messages to a receiver using the same event and type while maintaining the atomicity of the messages. The sending process sends a \"ready-to-send\" message to the receiver and blocks until the receiving process signals that it is ready. The receiver returns to the sender a new event, its process ID negated, to be used in the transfer of the body of the message. The introduction of the second event allows multi-packet messages, using the same event and destined to the same node, to be received with no mixing up of packets. The transport routines are also typically used while developing and debugging applications. Naturally, they have higher overhead than their network counterparts. The transport routines overcome the basic danger of LAM network message-passing - the lack of strong synchronization. A sending process can transmit a message that may never be received due to programming error or deadlock. This message will never be dropped or timed out. Some LAM process will always be stuck with it, waiting for a synchronizing drecv(2) or nrecv(2) that will never happen. If that unfortunate process is a buffer, it can be located by the user and swept clean (see sweep(1)). However, if the process is a link proprietor, the link is henceforth plugged and useless. The transport routines solve this problem by causing the sending process to block until it receives a \"ready-to-receive\" protocol message from the receiving process. If due to a programming error there is no receiving process at the other end, the \"ready-to-send\" message is guaranteed not to plug a link proprietor. The second advantage in this case is that the sender is stopped from flooding the system with messages that no receiver will consume. After the pre-synchronizing exchange, the network routines are invoked and the message is transmitted. Use of the network message structure passed to tsend() and trecv() is the same as described under nsend(2).","Process Name":"tsnd","Link":"https:\/\/linux.die.net\/man\/2\/tsnd"}},{"Process":{"Description":null,"Process Name":"tux","Link":"https:\/\/linux.die.net\/man\/2\/tux"}},{"Process":{"Description":null,"Process Name":"tuxcall","Link":"https:\/\/linux.die.net\/man\/2\/tuxcall"}}]
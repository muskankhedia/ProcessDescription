[{"Process":{"Description":"The Linux 2.0 kernel implements these calls to support old executables. These calls return structures which have grown since their first implementation, but old executables must continue to receive old smaller structures. Current executables should be linked with current libraries and never use these calls.","Process Name":"obsolete","Link":"https:\/\/linux.die.net\/man\/2\/obsolete"}},{"Process":{"Description":null,"Process Name":"oldfstat","Link":"https:\/\/linux.die.net\/man\/2\/oldfstat"}},{"Process":{"Description":null,"Process Name":"oldlstat","Link":"https:\/\/linux.die.net\/man\/2\/oldlstat"}},{"Process":{"Description":null,"Process Name":"oldolduname","Link":"https:\/\/linux.die.net\/man\/2\/oldolduname"}},{"Process":{"Description":null,"Process Name":"oldstat","Link":"https:\/\/linux.die.net\/man\/2\/oldstat"}},{"Process":{"Description":null,"Process Name":"olduname","Link":"https:\/\/linux.die.net\/man\/2\/olduname"}},{"Process":{"Description":"Given a pathname for a file, open() returns a file descriptor, a small, nonnegative integer for use in subsequent system calls ( read(2), write(2), lseek(2), fcntl(2), etc.). The file descriptor returned by a successful call will be the lowest-numbered file descriptor not currently open for the process. By default, the new file descriptor is set to remain open across an execve(2) (i.e., the FD_CLOEXEC file descriptor flag described in fcntl(2) is initially disabled; the O_CLOEXEC flag, described below, can be used to change this default). The file offset is set to the beginning of the file (see lseek(2)). A call to open() creates a new open file description, an entry in the system-wide table of open files. This entry records the file offset and the file status flags (modifiable via the fcntl(2) F_SETFL operation). A file descriptor is a reference to one of these entries; this reference is unaffected if pathname is subsequently removed or modified to refer to a different file. The new open file description is initially not shared with any other process, but sharing may arise via fork(2). The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR. These request opening the file read-only, write-only, or read\/write, respectively. In addition, zero or more file creation flags and file status flags can be bitwise-or'd in flags. The file creation flags are O_CLOEXEC, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_TRUNC, and O_TTY_INIT. The file status flags are all of the remaining flags listed below. The distinction between these two groups of flags is that the file status flags can be retrieved and (in some cases) modified using fcntl(2). The full list of file creation flags and file status flags is as follows: O_APPEND The file is opened in append mode. Before each write(2), the file offset is positioned at the end of the file, as if with lseek(2). O_APPEND may lead to corrupted files on NFS file systems if more than one process appends data to a file at once. This is because NFS does not support appending to a file, so the client kernel has to simulate it, which can't be done without a race condition. O_ASYNC Enable signal-driven I\/O: generate a signal ( SIGIO by default, but this can be changed via fcntl(2)) when input or output becomes possible on this file descriptor. This feature is only available for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. See fcntl(2) for further details. O_CLOEXEC (Since Linux 2.6.23) Enable the close-on-exec flag for the new file descriptor. Specifying this flag permits a program to avoid additional fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag. Additionally, use of this flag is essential in some multithreaded programs since using a separate fcntl(2) F_SETFD operation to set the FD_CLOEXEC flag does not suffice to avoid race conditions where one thread opens a file descriptor at the same time as another thread does a fork(2) plus execve(2). O_CREAT If the file does not exist it will be created. The owner (user ID) of the file is set to the effective user ID of the process. The group ownership (group ID) is set either to the effective group ID of the process or to the group ID of the parent directory (depending on file system type and mount options, and the mode of the parent directory, see the mount options bsdgroups and sysvgroups described in mount(8)). mode specifies the permissions to use in case a new file is created. This argument must be supplied when O_CREAT is specified in flags; if O_CREAT is not specified, then mode is ignored. The effective permissions are modified by the process's umask in the usual way: The permissions of the created file are (mode & ~umask). Note that this mode only applies to future accesses of the newly created file; the open() call that creates a read-only file may well return a read\/write file descriptor. The following symbolic constants are provided for mode: S_IRWXU 00700 user (file owner) has read, write and execute permission S_IRUSR 00400 user has read permission S_IWUSR 00200 user has write permission S_IXUSR 00100 user has execute permission S_IRWXG 00070 group has read, write and execute permission S_IRGRP 00040 group has read permission S_IWGRP 00020 group has write permission S_IXGRP 00010 group has execute permission S_IRWXO 00007 others have read, write and execute permission S_IROTH 00004 others have read permission S_IWOTH 00002 others have write permission S_IXOTH 00001 others have execute permission O_DIRECT (Since Linux 2.4.10) Try to minimize cache effects of the I\/O to and from this file. In general this will degrade performance, but it is useful in special situations, such as when applications do their own caching. File I\/O is done directly to\/from user-space buffers. The O_DIRECT flag on its own makes an effort to transfer data synchronously, but does not give the guarantees of the O_SYNC flag that data and necessary metadata are transferred. To guarantee synchronous I\/O, O_SYNC must be used in addition to O_DIRECT. See NOTES below for further discussion. A semantically similar (but deprecated) interface for block devices is described in raw(8). O_DIRECTORY If pathname is not a directory, cause the open to fail. This flag is Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-service problems if opendir(3) is called on a FIFO or tape device, but should not be used outside of the implementation of opendir(3). O_EXCL Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then open() will fail. When these two flags are specified, symbolic links are not followed: if pathname is a symbolic link, then open() fails regardless of where the symbolic link points to. In general, the behavior of O_EXCL is undefined if it is used without O_CREAT. There is one exception: on Linux 2.6 and later, O_EXCL can be used without O_CREAT if pathname refers to a block device. If the block device is in use by the system (e.g., mounted), open() fails with the error EBUSY. On NFS, O_EXCL is only supported when using NFSv3 or later on kernel 2.6 or later. In NFS environments where O_EXCL support is not provided, programs that rely on it for performing locking tasks will contain a race condition. Portable programs that want to perform atomic file locking using a lockfile, and need to avoid reliance on NFS support for O_EXCL, can create a unique file on the same file system (e.g., incorporating hostname and PID), and use link(2) to make a link to the lockfile. If link(2) returns 0, the lock is successful. Otherwise, use stat(2) on the unique file to check if its link count has increased to 2, in which case the lock is also successful. O_LARGEFILE (LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened. The _LARGEFILE64_SOURCE macro must be defined (before including any header files) in order to obtain this definition. Setting the _FILE_OFFSET_BITS feature test macro to 64 (rather than using O_LARGEFILE) is the preferred method of accessing large files on 32-bit systems (see feature_test_macros(7)). O_NOATIME (Since Linux 2.6.8) Do not update the file last access time ( st_atime in the inode) when the file is read(2). This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount of disk activity. This flag may not be effective on all file systems. One example is NFS, where the server maintains the access time. O_NOCTTY If pathname refers to a terminal device--see tty(4)--it will not become the process's controlling terminal even if the process does not have one. O_NOFOLLOW If pathname is a symbolic link, then the open fails. This is a FreeBSD extension, which was added to Linux in version 2.1.126. Symbolic links in earlier components of the pathname will still be followed. O_NONBLOCK or O_NDELAY When possible, the file is opened in nonblocking mode. Neither the open() nor any subsequent operations on the file descriptor which is returned will cause the calling process to wait. For the handling of FIFOs (named pipes), see also fifo(7). For a discussion of the effect of O_NONBLOCK in conjunction with mandatory file locks and with file leases, see fcntl(2). O_SYNC The file is opened for synchronous I\/O. Any write(2)s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying hardware. But see NOTES below. O_TRUNC If the file already exists and is a regular file and the open mode allows writing (i.e., is O_RDWR or O_WRONLY) it will be truncated to length 0. If the file is a FIFO or terminal device file, the O_TRUNC flag is ignored. Otherwise the effect of O_TRUNC is unspecified. Some of these optional flags can be altered using fcntl(2) after the file has been opened. creat() is equivalent to open() with flags equal to O_CREAT|O_WRONLY|O_TRUNC.","Process Name":"open","Link":"https:\/\/linux.die.net\/man\/2\/open"}},{"Process":{"Description":null,"Process Name":"openat","Link":"https:\/\/linux.die.net\/man\/2\/openat"}},{"Process":{"Description":"This family of functions is used to do low-level port input and output. The out* functions do port output, the in* functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix functions pause until the I\/O completes. They are primarily designed for internal kernel use, but can be used from user space. You must compile with -O or -O2 or similar. The functions are defined as inline macros, and will not be substituted in without optimization enabled, causing unresolved references at link time. You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I\/O ports in question. Failure to do this will cause the application to receive a segmentation fault.","Process Name":"outb","Link":"https:\/\/linux.die.net\/man\/2\/outb"}},{"Process":{"Description":null,"Process Name":"outb_p","Link":"https:\/\/linux.die.net\/man\/2\/outb_p"}},{"Process":{"Description":"This family of functions is used to do low-level port input and output. The out* functions do port output, the in* functions do port input; the b-suffix functions are byte-width and the w-suffix functions word-width; the _p-suffix functions pause until the I\/O completes. They are primarily designed for internal kernel use, but can be used from user space. You must compile with -O or -O2 or similar. The functions are defined as inline macros, and will not be substituted in without optimization enabled, causing unresolved references at link time. You use ioperm(2) or alternatively iopl(2) to tell the kernel to allow the user space application to access the I\/O ports in question. Failure to do this will cause the application to receive a segmentation fault.","Process Name":"outl","Link":"https:\/\/linux.die.net\/man\/2\/outl"}},{"Process":{"Description":null,"Process Name":"outl_p","Link":"https:\/\/linux.die.net\/man\/2\/outl_p"}},{"Process":{"Description":null,"Process Name":"outsb","Link":"https:\/\/linux.die.net\/man\/2\/outsb"}},{"Process":{"Description":null,"Process Name":"outsl","Link":"https:\/\/linux.die.net\/man\/2\/outsl"}},{"Process":{"Description":null,"Process Name":"outsw","Link":"https:\/\/linux.die.net\/man\/2\/outsw"}},{"Process":{"Description":null,"Process Name":"outw","Link":"https:\/\/linux.die.net\/man\/2\/outw"}},{"Process":{"Description":null,"Process Name":"outw_p","Link":"https:\/\/linux.die.net\/man\/2\/outw_p"}}]
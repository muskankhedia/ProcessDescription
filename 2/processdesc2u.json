[{"Process":{"Description":"The getrlimit() and setrlimit() system calls get and set resource limits respectively. Each resource has an associated soft and hard limit, as defined by the rlimit structure: struct rlimit {\n    rlim_t rlim_cur;  \/* Soft limit *\/\n    rlim_t rlim_max;  \/* Hard limit (ceiling for rlim_cur) *\/\n}; The soft limit is the value that the kernel enforces for the corresponding resource. The hard limit acts as a ceiling for the soft limit: an unprivileged process may only set its soft limit to a value in the range from 0 up to the hard limit, and (irreversibly) lower its hard limit. A privileged process (under Linux: one with the CAP_SYS_RESOURCE capability) may make arbitrary changes to either limit value. The value RLIM_INFINITY denotes no limit on a resource (both in the structure returned by getrlimit() and in the structure passed to setrlimit()). The resource argument must be one of: RLIMIT_AS The maximum size of the process's virtual memory (address space) in bytes. This limit affects calls to brk(2), mmap(2) and mremap(2), which fail with the error ENOMEM upon exceeding this limit. Also automatic stack expansion will fail (and generate a SIGSEGV that kills the process if no alternate stack has been made available via sigaltstack(2)). Since the value is a long, on machines with a 32-bit long either this limit is at most 2 GiB, or this resource is unlimited. RLIMIT_CORE Maximum size of core file. When 0 no core dump files are created. When nonzero, larger dumps are truncated to this size. RLIMIT_CPU CPU time limit in seconds. When the process reaches the soft limit, it is sent a SIGXCPU signal. The default action for this signal is to terminate the process. However, the signal can be caught, and the handler can return control to the main program. If the process continues to consume CPU time, it will be sent SIGXCPU once per second until the hard limit is reached, at which time it is sent SIGKILL. (This latter point describes Linux behavior. Implementations vary in how they treat processes which continue to consume CPU time after reaching the soft limit. Portable applications that need to catch this signal should perform an orderly termination upon first receipt of SIGXCPU.) RLIMIT_DATA The maximum size of the process's data segment (initialized data, uninitialized data, and heap). This limit affects calls to brk(2) and sbrk(2), which fail with the error ENOMEM upon encountering the soft limit of this resource. RLIMIT_FSIZE The maximum size of files that the process may create. Attempts to extend a file beyond this limit result in delivery of a SIGXFSZ signal. By default, this signal terminates a process, but a process can catch this signal instead, in which case the relevant system call (e.g., write(2), truncate(2)) fails with the error EFBIG. RLIMIT_LOCKS (Early Linux 2.4 only) A limit on the combined number of flock(2) locks and fcntl(2) leases that this process may establish. RLIMIT_MEMLOCK The maximum number of bytes of memory that may be locked into RAM. In effect this limit is rounded down to the nearest multiple of the system page size. This limit affects mlock(2) and mlockall(2) and the mmap(2) MAP_LOCKED operation. Since Linux 2.6.9 it also affects the shmctl(2) SHM_LOCK operation, where it sets a maximum on the total bytes in shared memory segments (see shmget(2)) that may be locked by the real user ID of the calling process. The shmctl(2) SHM_LOCK locks are accounted for separately from the per-process memory locks established by mlock(2), mlockall(2), and mmap(2) MAP_LOCKED; a process can lock bytes up to this limit in each of these two categories. In Linux kernels before 2.6.9, this limit controlled the amount of memory that could be locked by a privileged process. Since Linux 2.6.9, no limits are placed on the amount of memory that a privileged process may lock, and this limit instead governs the amount of memory that an unprivileged process may lock. RLIMIT_MSGQUEUE (Since Linux 2.6.8) Specifies the limit on the number of bytes that can be allocated for POSIX message queues for the real user ID of the calling process. This limit is enforced for mq_open(3). Each message queue that the user creates counts (until it is removed) against this limit according to the formula: bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n        attr.mq_maxmsg * attr.mq_msgsize where attr is the mq_attr structure specified as the fourth argument to mq_open(3). The first addend in the formula, which includes sizeof(struct msg_msg *) (4 bytes on Linux\/i386), ensures that the user cannot create an unlimited number of zero-length messages (such messages nevertheless each consume some system memory for bookkeeping overhead). RLIMIT_NICE (since Linux 2.6.12, but see BUGS below) Specifies a ceiling to which the process's nice value can be raised using setpriority(2) or nice(2). The actual ceiling for the nice value is calculated as 20 - rlim_cur. (This strangeness occurs because negative numbers cannot be specified as resource limit values, since they typically have special meanings. For example, RLIM_INFINITY typically is the same as -1.) RLIMIT_NOFILE Specifies a value one greater than the maximum file descriptor number that can be opened by this process. Attempts ( open(2), pipe(2), dup(2), etc.) to exceed this limit yield the error EMFILE. (Historically, this limit was named RLIMIT_OFILE on BSD.) RLIMIT_NPROC The maximum number of processes (or, more precisely on Linux, threads) that can be created for the real user ID of the calling process. Upon encountering this limit, fork(2) fails with the error EAGAIN. RLIMIT_RSS Specifies the limit (in pages) of the process's resident set (the number of virtual pages resident in RAM). This limit only has effect in Linux 2.4.x, x < 30, and there only affects calls to madvise(2) specifying MADV_WILLNEED. RLIMIT_RTPRIO (Since Linux 2.6.12, but see BUGS) Specifies a ceiling on the real-time priority that may be set for this process using sched_setscheduler(2) and sched_setparam(2). RLIMIT_RTTIME (Since Linux 2.6.25) Specifies a limit (in microseconds) on the amount of CPU time that a process scheduled under a real-time scheduling policy may consume without making a blocking system call. For the purpose of this limit, each time a process makes a blocking system call, the count of its consumed CPU time is reset to zero. The CPU time count is not reset if the process continues trying to use the CPU but is preempted, its time slice expires, or it calls sched_yield(2). Upon reaching the soft limit, the process is sent a SIGXCPU signal. If the process catches or ignores this signal and continues consuming CPU time, then SIGXCPU will be generated once each second until the hard limit is reached, at which point the process is sent a SIGKILL signal. The intended use of this limit is to stop a runaway real-time process from locking up the system. RLIMIT_SIGPENDING (Since Linux 2.6.8) Specifies the limit on the number of signals that may be queued for the real user ID of the calling process. Both standard and real-time signals are counted for the purpose of checking this limit. However, the limit is only enforced for sigqueue(3); it is always possible to use kill(2) to queue one instance of any of the signals that are not already queued to the process. RLIMIT_STACK The maximum size of the process stack, in bytes. Upon reaching this limit, a SIGSEGV signal is generated. To handle this signal, a process must employ an alternate signal stack ( sigaltstack(2)). Since Linux 2.6.23, this limit also determines the amount of space used for the process's command-line arguments and environment variables; for details, see execve(2). prlimit() The Linux-specific prlimit() system call combines and extends the functionality of setrlimit() and getrlimit(). It can be used to both set and get the resource limits of an arbitrary process. The resource argument has the same meaning as for setrlimit() and getrlimit(). If the new_limit argument is a not NULL, then the rlimit structure to which it points is used to set new values for the soft and hard limits for resource. If the old_limit argument is a not NULL, then a successful call to prlimit() places the previous soft and hard limits for resource in the rlimit structure pointed to by old_limit. The pid argument specifies the ID of the process on which the call is to operate. If pid is 0, then the call applies to the calling process. To set or get the resources of a process other than itself, the caller must have the CAP_SYS_RESOURCE capability, or the real, effective, and saved set user IDs of the target process must match the real user ID of the caller and the real, effective, and saved set group IDs of the target process must match the real group ID of the caller.","Process Name":"ugetrlimit","Link":"https:\/\/linux.die.net\/man\/2\/ugetrlimit"}},{"Process":{"Description":null,"Process Name":"umask","Link":"https:\/\/linux.die.net\/man\/2\/umask"}},{"Process":{"Description":"umount() and umount2() remove the attachment of the (topmost) file system mounted on target. Appropriate privilege (Linux: the CAP_SYS_ADMIN capability) is required to unmount file systems. Linux 2.1.116 added the umount2() system call, which, like umount(), unmounts a target, but allows additional flags controlling the behavior of the operation: MNT_FORCE (since Linux 2.1.116) Force unmount even if busy. This can cause data loss. (Only for NFS mounts.) MNT_DETACH (since Linux 2.4.11) Perform a lazy unmount: make the mount point unavailable for new accesses, and actually perform the unmount when the mount point ceases to be busy. MNT_EXPIRE (since Linux 2.6.8) Mark the mount point as expired. If a mount point is not currently in use, then an initial call to umount2() with this flag fails with the error EAGAIN, but marks the mount point as expired. The mount point remains expired as long as it isn't accessed by any process. A second umount2() call specifying MNT_EXPIRE unmounts an expired mount point. This flag cannot be specified with either MNT_FORCE or MNT_DETACH. UMOUNT_NOFOLLOW (since Linux 2.6.34) Don't dereference target if it is a symbolic link. This flag allows security problems to be avoided in set-user-ID- root programs that allow unprivileged users to unmount file systems.","Process Name":"umount","Link":"https:\/\/linux.die.net\/man\/2\/umount"}},{"Process":{"Description":null,"Process Name":"umount2","Link":"https:\/\/linux.die.net\/man\/2\/umount2"}},{"Process":{"Description":"uname() returns system information in the structure pointed to by buf. The utsname struct is defined in <sys\/utsname.h>: struct utsname {\n    char sysname[];    \/* Operating system name (e.g., \"Linux\") *\/\n    char nodename[];   \/* Name within \"some implementation-defined\n                          network\" *\/\n    char release[];    \/* Operating system release (e.g., \"2.6.28\") *\/\n    char version[];    \/* Operating system version *\/\n    char machine[];    \/* Hardware identifier *\/\n#ifdef _GNU_SOURCE\n    char domainname[]; \/* NIS or YP domain name *\/\n#endif\n}; The length of the arrays in a struct utsname is unspecified (see NOTES); the fields are terminated by a null byte ('\\0').","Process Name":"uname","Link":"https:\/\/linux.die.net\/man\/2\/uname"}},{"Process":{"Description":null,"Process Name":"undocumented","Link":"https:\/\/linux.die.net\/man\/2\/undocumented"}},{"Process":{"Description":null,"Process Name":"unimplemented","Link":"https:\/\/linux.die.net\/man\/2\/unimplemented"}},{"Process":{"Description":"unlink() deletes a name from the file system. If that name was the last link to a file and no processes have the file open the file is deleted and the space it was using is made available for reuse. If the name was the last link to a file but any processes still have the file open the file will remain in existence until the last file descriptor referring to it is closed. If the name referred to a symbolic link the link is removed. If the name referred to a socket, fifo or device the name for it is removed but processes which have the object open may continue to use it.","Process Name":"unlink","Link":"https:\/\/linux.die.net\/man\/2\/unlink"}},{"Process":{"Description":null,"Process Name":"unlinkat","Link":"https:\/\/linux.die.net\/man\/2\/unlinkat"}},{"Process":{"Description":"unshare() allows a process to disassociate parts of its execution context that are currently being shared with other processes. Part of the execution context, such as the mount namespace, is shared implicitly when a new process is created using fork(2) or vfork(2), while other parts, such as virtual memory, may be shared by explicit request when creating a process using clone(2). The main use of unshare() is to allow a process to control its shared execution context without creating a new process. The flags argument is a bit mask that specifies which parts of the execution context should be unshared. This argument is specified by ORing together zero or more of the following constants: CLONE_FILES Reverse the effect of the clone(2) CLONE_FILES flag. Unshare the file descriptor table, so that the calling process no longer shares its file descriptors with any other process. CLONE_FS Reverse the effect of the clone(2) CLONE_FS flag. Unshare file system attributes, so that the calling process no longer shares its root directory ( chroot(2)), current directory ( chdir(2)), or umask ( umask(2)) attributes with any other process. CLONE_NEWIPC (since Linux 2.6.19) This flag has the same effect as the clone(2) CLONE_NEWIPC flag. Unshare the System V IPC namespace, so that the calling process has a private copy of the System V IPC namespace which is not shared with any other process. Specifying this flag automatically implies CLONE_SYSVSEM as well. Use of CLONE_NEWIPC requires the CAP_SYS_ADMIN capability. CLONE_NEWNET (since Linux 2.6.24) This flag has the same effect as the clone(2) CLONE_NEWNET flag. Unshare the network namespace, so that the calling process is moved into a new network namespace which is not shared with any previously existing process. Use of CLONE_NEWNET requires the CAP_SYS_ADMIN capability. CLONE_NEWNS This flag has the same effect as the clone(2) CLONE_NEWNS flag. Unshare the mount namespace, so that the calling process has a private copy of its namespace which is not shared with any other process. Specifying this flag automatically implies CLONE_FS as well. Use of CLONE_NEWNS requires the CAP_SYS_ADMIN capability. CLONE_NEWUTS (since Linux 2.6.19) This flag has the same effect as the clone(2) CLONE_NEWUTS flag. Unshare the UTS IPC namespace, so that the calling process has a private copy of the UTS namespace which is not shared with any other process. Use of CLONE_NEWUTS requires the CAP_SYS_ADMIN capability. CLONE_SYSVSEM (since Linux 2.6.26) This flag reverses the effect of the clone(2) CLONE_SYSVSEM flag. Unshare System V semaphore undo values, so that the calling process has a private copy which is not shared with any other process. Use of CLONE_SYSVSEM requires the CAP_SYS_ADMIN capability. If flags is specified as zero, then unshare() is a no-op; no changes are made to the calling process's execution context.","Process Name":"unshare","Link":"https:\/\/linux.die.net\/man\/2\/unshare"}},{"Process":{"Description":null,"Process Name":"uselib","Link":"https:\/\/linux.die.net\/man\/2\/uselib"}},{"Process":{"Description":"ustat() returns information about a mounted file system. dev is a device number identifying a device containing a mounted file system. ubuf is a pointer to a ustat structure that contains the following members: daddr_t f_tfree;      \/* Total free blocks *\/\nino_t   f_tinode;     \/* Number of free inodes *\/\nchar    f_fname[6];   \/* Filsys name *\/\nchar    f_fpack[6];   \/* Filsys pack name *\/ The last two fields, f_fname and f_fpack, are not implemented and will always be filled with null bytes ('\\0').","Process Name":"ustat","Link":"https:\/\/linux.die.net\/man\/2\/ustat"}},{"Process":{"Description":null,"Process Name":"utime","Link":"https:\/\/linux.die.net\/man\/2\/utime"}},{"Process":{"Description":"utimensat() and futimens() update the timestamps of a file with nanosecond precision. This contrasts with the historical utime(2) and utimes(2), which permit only second and microsecond precision, respectively, when setting file timestamps. With utimensat() the file is specified via the pathname given in pathname. With futimens() the file whose timestamps are to be updated is specified via an open file descriptor, fd. For both calls, the new file timestamps are specified in the array times: times[0] specifies the new \"last access time\" (atime); times[1] specifies the new \"last modification time\" (mtime). Each of the elements of times specifies a time as the number of seconds and nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC). This information is conveyed in a structure of the following form: struct timespec {\n    time_t tv_sec;        \/* seconds *\/\n    long   tv_nsec;       \/* nanoseconds *\/\n}; Updated file timestamps are set to the greatest value supported by the file system that is not greater than the specified time. If the tv_nsec field of one of the timespec structures has the special value UTIME_NOW, then the corresponding file timestamp is set to the current time. If the tv_nsec field of one of the timespec structures has the special value UTIME_OMIT, then the corresponding file timestamp is left unchanged. In both of these cases, the value of the corresponding tv_sec field is ignored. If times is NULL, then both timestamps are set to the current time. Permissions requirements To set both file timestamps to the current time (i.e., times is NULL, or both tv_nsec fields specify UTIME_NOW), either: 1. the caller must have write access to the file; 2. the caller's effective user ID must match the owner of the file; or 3. the caller must have appropriate privileges. To make any change other than setting both timestamps to the current time (i.e., times is not NULL, and both tv_nsec fields are not UTIME_NOW and both tv_nsec fields are not UTIME_OMIT), either condition 2 or 3 above must apply. If both tv_nsec fields are specified as UTIME_OMIT, then no file ownership or permission checks are performed, and the file timestamps are not modified, but other error conditions may still be detected. utimensat() specifics If pathname is relative, then by default it is interpreted relative to the directory referred to by the open file descriptor, dirfd (rather than relative to the current working directory of the calling process, as is done by utimes(2) for a relative pathname). See openat(2) for an explanation of why this can be useful. If pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the current working directory of the calling process (like utimes(2)). If pathname is absolute, then dirfd is ignored. The flags field is a bit mask that may be 0, or include the following constant, defined in <fcntl.h>: AT_SYMLINK_NOFOLLOW If pathname specifies a symbolic link, then update the timestamps of the link, rather than the file to which it refers.","Process Name":"utimensat","Link":"https:\/\/linux.die.net\/man\/2\/utimensat"}},{"Process":{"Description":null,"Process Name":"utimes","Link":"https:\/\/linux.die.net\/man\/2\/utimes"}}]
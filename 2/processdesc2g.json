[{"Process":{"Description":null,"Process Name":"gall","Link":"https:\/\/linux.die.net\/man\/2\/gall"}},{"Process":{"Description":null,"Process Name":"gcomps","Link":"https:\/\/linux.die.net\/man\/2\/gcomps"}},{"Process":{"Description":null,"Process Name":"get_kernel_syms","Link":"https:\/\/linux.die.net\/man\/2\/get_kernel_syms"}},{"Process":{"Description":null,"Process Name":"get_mempolicy","Link":"https:\/\/linux.die.net\/man\/2\/get_mempolicy"}},{"Process":{"Description":null,"Process Name":"get_robust_list","Link":"https:\/\/linux.die.net\/man\/2\/get_robust_list"}},{"Process":{"Description":null,"Process Name":"get_thread_area","Link":"https:\/\/linux.die.net\/man\/2\/get_thread_area"}},{"Process":{"Description":null,"Process Name":"getall","Link":"https:\/\/linux.die.net\/man\/2\/getall"}},{"Process":{"Description":null,"Process Name":"getcomps","Link":"https:\/\/linux.die.net\/man\/2\/getcomps"}},{"Process":{"Description":"In a System V-like environment, one has the two types mcontext_t and ucontext_t defined in <ucontext.h> and the four functions getcontext(), setcontext(), makecontext(3) and swapcontext(3) that allow user-level context switching between multiple threads of control within a process. The mcontext_t type is machine-dependent and opaque. The ucontext_t type is a structure that has at least the following fields: typedef struct ucontext {\n    struct ucontext *uc_link;\n    sigset_t         uc_sigmask;\n    stack_t          uc_stack;\n    mcontext_t       uc_mcontext;\n    ...\n} ucontext_t; with sigset_t and stack_t defined in <signal.h>. Here uc_link points to the context that will be resumed when the current context terminates (in case the current context was created using makecontext(3)), uc_sigmask is the set of signals blocked in this context (see sigprocmask(2)), uc_stack is the stack used by this context (see sigaltstack(2)), and uc_mcontext is the machine-specific representation of the saved context, that includes the calling thread's machine registers. The function getcontext() initializes the structure pointed at by ucp to the currently active context. The function setcontext() restores the user context pointed at by ucp. A successful call does not return. The context should have been obtained by a call of getcontext(), or makecontext(3), or passed as third argument to a signal handler. If the context was obtained by a call of getcontext(), program execution continues as if this call just returned. If the context was obtained by a call of makecontext(3), program execution continues by a call to the function func specified as the second argument of that call to makecontext(3). When the function func returns, we continue with the uc_link member of the structure ucp specified as the first argument of that call to makecontext(3). When this member is NULL, the thread exits. If the context was obtained by a call to a signal handler, then old standard text says that \"program execution continues with the program instruction following the instruction interrupted by the signal\". However, this sentence was removed in SUSv2, and the present verdict is \"the result is unspecified\".","Process Name":"getcontext","Link":"https:\/\/linux.die.net\/man\/2\/getcontext"}},{"Process":{"Description":null,"Process Name":"getcpu","Link":"https:\/\/linux.die.net\/man\/2\/getcpu"}},{"Process":{"Description":"These functions return a null-terminated string containing an absolute pathname that is the current working directory of the calling process. The pathname is returned as the function result and via the argument buf, if present. The getcwd() function copies an absolute pathname of the current working directory to the array pointed to by buf, which is of length size. If the length of the absolute pathname of the current working directory, including the terminating null byte, exceeds size bytes, NULL is returned, and errno is set to ERANGE; an application should check for this error, and allocate a larger buffer if necessary. As an extension to the POSIX.1-2001 standard, Linux (libc4, libc5, glibc) getcwd() allocates the buffer dynamically using malloc(3) if buf is NULL. In this case, the allocated buffer has the length size unless size is zero, when buf is allocated as big as necessary. The caller should free(3) the returned buffer. get_current_dir_name() will malloc(3) an array big enough to hold the absolute pathname of the current working directory. If the environment variable PWD is set, and its value is correct, then that value will be returned. The caller should free(3) the returned buffer. getwd() does not malloc(3) any memory. The buf argument should be a pointer to an array at least PATH_MAX bytes long. If the length of the absolute pathname of the current working directory, including the terminating null byte, exceeds PATH_MAX bytes, NULL is returned, and errno is set to ENAMETOOLONG. (Note that on some systems, PATH_MAX may not be a compile-time constant; furthermore, its value may depend on the file system, see pathconf(3).) For portability and security reasons, use of getwd() is deprecated.","Process Name":"getcwd","Link":"https:\/\/linux.die.net\/man\/2\/getcwd"}},{"Process":{"Description":null,"Process Name":"getdents","Link":"https:\/\/linux.die.net\/man\/2\/getdents"}},{"Process":{"Description":null,"Process Name":"getdents64","Link":"https:\/\/linux.die.net\/man\/2\/getdents64"}},{"Process":{"Description":null,"Process Name":"getdomainname","Link":"https:\/\/linux.die.net\/man\/2\/getdomainname"}},{"Process":{"Description":null,"Process Name":"getdtablesize","Link":"https:\/\/linux.die.net\/man\/2\/getdtablesize"}},{"Process":{"Description":null,"Process Name":"getegid","Link":"https:\/\/linux.die.net\/man\/2\/getegid"}},{"Process":{"Description":null,"Process Name":"getegid32","Link":"https:\/\/linux.die.net\/man\/2\/getegid32"}},{"Process":{"Description":null,"Process Name":"geteuid","Link":"https:\/\/linux.die.net\/man\/2\/geteuid"}},{"Process":{"Description":null,"Process Name":"geteuid32","Link":"https:\/\/linux.die.net\/man\/2\/geteuid32"}},{"Process":{"Description":null,"Process Name":"getgid","Link":"https:\/\/linux.die.net\/man\/2\/getgid"}},{"Process":{"Description":null,"Process Name":"getgid32","Link":"https:\/\/linux.die.net\/man\/2\/getgid32"}},{"Process":{"Description":null,"Process Name":"getgroups","Link":"https:\/\/linux.die.net\/man\/2\/getgroups"}},{"Process":{"Description":null,"Process Name":"getgroups32","Link":"https:\/\/linux.die.net\/man\/2\/getgroups32"}},{"Process":{"Description":"gethostid() and sethostid() respectively get or set a unique 32-bit identifier for the current machine. The 32-bit identifier is intended to be unique among all UNIX systems in existence. This normally resembles the Internet address for the local machine, as returned by gethostbyname(3), and thus usually never needs to be set. The sethostid() call is restricted to the superuser.","Process Name":"gethostid","Link":"https:\/\/linux.die.net\/man\/2\/gethostid"}},{"Process":{"Description":null,"Process Name":"gethostname","Link":"https:\/\/linux.die.net\/man\/2\/gethostname"}},{"Process":{"Description":"The system provides each process with three interval timers, each decrementing in a distinct time domain. When any timer expires, a signal is sent to the process, and the timer (potentially) restarts. ITIMER_REAL decrements in real time, and delivers SIGALRM upon expiration. ITIMER_VIRTUAL decrements only when the process is executing, and delivers SIGVTALRM upon expiration. ITIMER_PROF decrements both when the process executes and when the system is executing on behalf of the process. Coupled with ITIMER_VIRTUAL, this timer is usually used to profile the time spent by the application in user and kernel space. SIGPROF is delivered upon expiration. Timer values are defined by the following structures: struct itimerval {\n    struct timeval it_interval; \/* next value *\/\n    struct timeval it_value;    \/* current value *\/\n};\n\nstruct timeval {\n    time_t      tv_sec;         \/* seconds *\/\n    suseconds_t tv_usec;        \/* microseconds *\/\n}; The function getitimer() fills the structure pointed to by curr_value with the current setting for the timer specified by which (one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF). The element it_value is set to the amount of time remaining on the timer, or zero if the timer is disabled. Similarly, it_interval is set to the reset value. The function setitimer() sets the specified timer to the value in new_value. If old_value is non-NULL, the old value of the timer is stored there. Timers decrement from it_value to zero, generate a signal, and reset to it_interval. A timer which is set to zero (it_value is zero or the timer expires and it_interval is zero) stops. Both tv_sec and tv_usec are significant in determining the duration of a timer. Timers will never expire before the requested time, but may expire some (short) time afterward, which depends on the system timer resolution and on the system load; see time(7). (But see BUGS below.) Upon expiration, a signal will be generated and the timer reset. If the timer expires while the process is active (always true for ITIMER_VIRTUAL) the signal will be delivered immediately when generated. Otherwise the delivery will be offset by a small time dependent on the system loading.","Process Name":"getitimer","Link":"https:\/\/linux.die.net\/man\/2\/getitimer"}},{"Process":{"Description":null,"Process Name":"getjones","Link":"https:\/\/linux.die.net\/man\/2\/getjones"}},{"Process":{"Description":null,"Process Name":"getmsg","Link":"https:\/\/linux.die.net\/man\/2\/getmsg"}},{"Process":{"Description":null,"Process Name":"getnall","Link":"https:\/\/linux.die.net\/man\/2\/getnall"}},{"Process":{"Description":"These functions return node information obtained from the local route daemon, a modular component of the LAM daemon, regarding the currently running LAM network. A node is defined by its identifier, an arbitrary 32 bit value, and its type, a combination of flags describing the capabilities of the node. These flags (see constants(5) and\/or <net.h>) are: NT_ITB node running LAM natively NT_CAST node multicast, a group of nodes NT_WASTE node not part of main computing group NT_DISK node has a disk NT_TUBE node has a video display unit NT_JONES node is a neighbour of the local node NT_BOOT node is booted by the local node getnodeid() returns the local node identifier. getnodetype() returns the local node type. getorigin() returns the origin node identifier, from which LAM was booted. getncomp() returns the number of nodes marked for the \"main\" computation. A typical application will use most (maybe all) of the nodes in a parallel machine to compute portions of decomposed data. Programmers frequently need to know the number of these \"compute\" nodes. Other nodes may be present in the multicomputer to handle peripherals or sequential portions of an application. getnotb() returns the total number of OTB nodes. getnall() returns the total number of nodes in the system. getnjones() returns the caller's number of neighbour (directly connected) nodes. getntype() is a general function that is used to determine the number of nodes whose node types have certain bits set to certain values. This is a flexible tool which allows the user to obtain very specific information about the capabilities of nodes in the system. Type Inquiries You may need more detailed information on the number and types of nodes in the system than provided by the convenience functions. You may, for example, want to know the number of computing nodes with attached video displays. The getntype() function is used for this purpose. Node types are interpreted as bit fields, and each node type has a different bit set. A bitmask having all bits set, NT_ALL, is also available. Note that NT_ALL does not include NT_JONES nor NT_BOOT since these node characteristics are not inherent to the nodes, but depend on the node from which the query is made. The node types are thus: Nodetype Value Bitmask NT_ITB 1 ...00000001 NT_CAST 2 ...00000010 NT_WASTE 4 ...00000100 NT_DISK 8 ...00001000 NT_TUBE 16 ...00010000 NT_ALL 31 ...00011111 NT_JONES 32 ...00100000 NT_BOOT 64 ...01000000 The typemask argument to getntype() is used to specify which bits are of interest. These are set to 1, all others are set to 0. The nodetype argument is used to specify what values these bits should take. getntype() then compares the relevant bits (as specified by typemask) in the node type of each node in the system, to see if they have the appropriate value (as specified by nodetype). To learn the number of nodes that have video capabilities, the bits of interest are NT_WASTE and NT_TUBE, thus typemask is 20. NT_WASTE must be 0 and NT_TUBE must be 1, which combined gives nodetype as 16. The complete call to getntype() is: nnodes = getntype(NT_TUBE, NT_TUBE | NT_WASTE); To learn the number of compute nodes that have an attached video display, but no other capabilities, all bits must be considered and all bits except NT_TUBE must be clear (0). The complete function call is: nnodes = getntype(NT_TUBE, NT_ALL);","Process Name":"getnjones","Link":"https:\/\/linux.die.net\/man\/2\/getnjones"}},{"Process":{"Description":null,"Process Name":"getnodeid","Link":"https:\/\/linux.die.net\/man\/2\/getnodeid"}},{"Process":{"Description":null,"Process Name":"getnodes","Link":"https:\/\/linux.die.net\/man\/2\/getnodes"}},{"Process":{"Description":null,"Process Name":"getnodetype","Link":"https:\/\/linux.die.net\/man\/2\/getnodetype"}},{"Process":{"Description":"These functions return node information obtained from the local route daemon, a modular component of the LAM daemon, regarding the currently running LAM network. A node is defined by its identifier, an arbitrary 32 bit value, and its type, a combination of flags describing the capabilities of the node. These flags (see constants(5) and\/or <net.h>) are: NT_ITB node running LAM natively NT_CAST node multicast, a group of nodes NT_WASTE node not part of main computing group NT_DISK node has a disk NT_TUBE node has a video display unit NT_JONES node is a neighbour of the local node NT_BOOT node is booted by the local node getnodeid() returns the local node identifier. getnodetype() returns the local node type. getorigin() returns the origin node identifier, from which LAM was booted. getncomp() returns the number of nodes marked for the \"main\" computation. A typical application will use most (maybe all) of the nodes in a parallel machine to compute portions of decomposed data. Programmers frequently need to know the number of these \"compute\" nodes. Other nodes may be present in the multicomputer to handle peripherals or sequential portions of an application. getnotb() returns the total number of OTB nodes. getnall() returns the total number of nodes in the system. getnjones() returns the caller's number of neighbour (directly connected) nodes. getntype() is a general function that is used to determine the number of nodes whose node types have certain bits set to certain values. This is a flexible tool which allows the user to obtain very specific information about the capabilities of nodes in the system. Type Inquiries You may need more detailed information on the number and types of nodes in the system than provided by the convenience functions. You may, for example, want to know the number of computing nodes with attached video displays. The getntype() function is used for this purpose. Node types are interpreted as bit fields, and each node type has a different bit set. A bitmask having all bits set, NT_ALL, is also available. Note that NT_ALL does not include NT_JONES nor NT_BOOT since these node characteristics are not inherent to the nodes, but depend on the node from which the query is made. The node types are thus: Nodetype Value Bitmask NT_ITB 1 ...00000001 NT_CAST 2 ...00000010 NT_WASTE 4 ...00000100 NT_DISK 8 ...00001000 NT_TUBE 16 ...00010000 NT_ALL 31 ...00011111 NT_JONES 32 ...00100000 NT_BOOT 64 ...01000000 The typemask argument to getntype() is used to specify which bits are of interest. These are set to 1, all others are set to 0. The nodetype argument is used to specify what values these bits should take. getntype() then compares the relevant bits (as specified by typemask) in the node type of each node in the system, to see if they have the appropriate value (as specified by nodetype). To learn the number of nodes that have video capabilities, the bits of interest are NT_WASTE and NT_TUBE, thus typemask is 20. NT_WASTE must be 0 and NT_TUBE must be 1, which combined gives nodetype as 16. The complete call to getntype() is: nnodes = getntype(NT_TUBE, NT_TUBE | NT_WASTE); To learn the number of compute nodes that have an attached video display, but no other capabilities, all bits must be considered and all bits except NT_TUBE must be clear (0). The complete function call is: nnodes = getntype(NT_TUBE, NT_ALL);","Process Name":"getnotb","Link":"https:\/\/linux.die.net\/man\/2\/getnotb"}},{"Process":{"Description":null,"Process Name":"getntype","Link":"https:\/\/linux.die.net\/man\/2\/getntype"}},{"Process":{"Description":"These functions return node information obtained from the local route daemon, a modular component of the LAM daemon, regarding the currently running LAM network. A node is defined by its identifier, an arbitrary 32 bit value, and its type, a combination of flags describing the capabilities of the node. These flags (see constants(5) and\/or <net.h>) are: NT_ITB node running LAM natively NT_CAST node multicast, a group of nodes NT_WASTE node not part of main computing group NT_DISK node has a disk NT_TUBE node has a video display unit NT_JONES node is a neighbour of the local node NT_BOOT node is booted by the local node getnodeid() returns the local node identifier. getnodetype() returns the local node type. getorigin() returns the origin node identifier, from which LAM was booted. getncomp() returns the number of nodes marked for the \"main\" computation. A typical application will use most (maybe all) of the nodes in a parallel machine to compute portions of decomposed data. Programmers frequently need to know the number of these \"compute\" nodes. Other nodes may be present in the multicomputer to handle peripherals or sequential portions of an application. getnotb() returns the total number of OTB nodes. getnall() returns the total number of nodes in the system. getnjones() returns the caller's number of neighbour (directly connected) nodes. getntype() is a general function that is used to determine the number of nodes whose node types have certain bits set to certain values. This is a flexible tool which allows the user to obtain very specific information about the capabilities of nodes in the system. Type Inquiries You may need more detailed information on the number and types of nodes in the system than provided by the convenience functions. You may, for example, want to know the number of computing nodes with attached video displays. The getntype() function is used for this purpose. Node types are interpreted as bit fields, and each node type has a different bit set. A bitmask having all bits set, NT_ALL, is also available. Note that NT_ALL does not include NT_JONES nor NT_BOOT since these node characteristics are not inherent to the nodes, but depend on the node from which the query is made. The node types are thus: Nodetype Value Bitmask NT_ITB 1 ...00000001 NT_CAST 2 ...00000010 NT_WASTE 4 ...00000100 NT_DISK 8 ...00001000 NT_TUBE 16 ...00010000 NT_ALL 31 ...00011111 NT_JONES 32 ...00100000 NT_BOOT 64 ...01000000 The typemask argument to getntype() is used to specify which bits are of interest. These are set to 1, all others are set to 0. The nodetype argument is used to specify what values these bits should take. getntype() then compares the relevant bits (as specified by typemask) in the node type of each node in the system, to see if they have the appropriate value (as specified by nodetype). To learn the number of nodes that have video capabilities, the bits of interest are NT_WASTE and NT_TUBE, thus typemask is 20. NT_WASTE must be 0 and NT_TUBE must be 1, which combined gives nodetype as 16. The complete call to getntype() is: nnodes = getntype(NT_TUBE, NT_TUBE | NT_WASTE); To learn the number of compute nodes that have an attached video display, but no other capabilities, all bits must be considered and all bits except NT_TUBE must be clear (0). The complete function call is: nnodes = getntype(NT_TUBE, NT_ALL);","Process Name":"getorigin","Link":"https:\/\/linux.die.net\/man\/2\/getorigin"}},{"Process":{"Description":null,"Process Name":"getotbs","Link":"https:\/\/linux.die.net\/man\/2\/getotbs"}},{"Process":{"Description":null,"Process Name":"getpagesize","Link":"https:\/\/linux.die.net\/man\/2\/getpagesize"}},{"Process":{"Description":null,"Process Name":"getpeername","Link":"https:\/\/linux.die.net\/man\/2\/getpeername"}},{"Process":{"Description":null,"Process Name":"getpgid","Link":"https:\/\/linux.die.net\/man\/2\/getpgid"}},{"Process":{"Description":null,"Process Name":"getpgrp","Link":"https:\/\/linux.die.net\/man\/2\/getpgrp"}},{"Process":{"Description":null,"Process Name":"getpid","Link":"https:\/\/linux.die.net\/man\/2\/getpid"}},{"Process":{"Description":null,"Process Name":"getpmsg","Link":"https:\/\/linux.die.net\/man\/2\/getpmsg"}},{"Process":{"Description":"getpid() returns the process ID of the calling process. (This is often used by routines that generate unique temporary filenames.) getppid() returns the process ID of the parent of the calling process.","Process Name":"getppid","Link":"https:\/\/linux.die.net\/man\/2\/getppid"}},{"Process":{"Description":null,"Process Name":"getpriority","Link":"https:\/\/linux.die.net\/man\/2\/getpriority"}},{"Process":{"Description":null,"Process Name":"getrent","Link":"https:\/\/linux.die.net\/man\/2\/getrent"}},{"Process":{"Description":null,"Process Name":"getrentc","Link":"https:\/\/linux.die.net\/man\/2\/getrentc"}},{"Process":{"Description":"getresuid() returns the real UID, the effective UID, and the saved set-user-ID of the calling process, in the arguments ruid, euid, and suid, respectively. getresgid() performs the analogous task for the process's group IDs.","Process Name":"getresgid","Link":"https:\/\/linux.die.net\/man\/2\/getresgid"}},{"Process":{"Description":null,"Process Name":"getresgid32","Link":"https:\/\/linux.die.net\/man\/2\/getresgid32"}},{"Process":{"Description":"getresuid() returns the real UID, the effective UID, and the saved set-user-ID of the calling process, in the arguments ruid, euid, and suid, respectively. getresgid() performs the analogous task for the process's group IDs.","Process Name":"getresuid","Link":"https:\/\/linux.die.net\/man\/2\/getresuid"}},{"Process":{"Description":null,"Process Name":"getresuid32","Link":"https:\/\/linux.die.net\/man\/2\/getresuid32"}},{"Process":{"Description":null,"Process Name":"getrlimit","Link":"https:\/\/linux.die.net\/man\/2\/getrlimit"}},{"Process":{"Description":null,"Process Name":"getroute","Link":"https:\/\/linux.die.net\/man\/2\/getroute"}},{"Process":{"Description":"These functions return information obtained from the local route daemon, a modular component of the LAM daemon. getrent() and getrentc() accept a pointer to a route structure, defined in <rreq.h>: struct route { int r_nodeid; int r_event; int r_link; int r_event2; int r_link2; int r_nodetype; }; The structure fields hold the following information. r_nodeid destination node ID r_event forwarding event, representing the best suggested route to the destination node r_link forwarding link associated with r_event, if r_event is a datalink output process r_event2 secondary forwarding event, representing a non-reconvergent route (primarily used for multicasting) with respect to other destinations r_link2 forwarding link associated with r_event2, if r_event2 is a datalink output process r_nodetype node type of destination node (see getntype(2)) getrent() sends a request for route information to the route daemon. The r_nodeid field must be set by the caller to the nodeid of the destination node whose route table entry is required. All other fields are filled by the function. getrentc() has the exact functionality of getrent(), except that it caches the recently accessed route table entries. Later access to the same entries are faster. getrentc() first checks the cache for the route entry of the given nodeid. If the entry is found, the requested information is returned. Otherwise, getrent() is called, returning a copy of the route table entry from the route daemon. This entry is then stored in the cache. The remaining functions are wrappers for getrentc(). getroute() accepts a network message descriptor with the destination node and event fields set and fills in the forwarding fields. getroute2() is similar to getroute() except that the secondary routing information is used. getrtype() accepts a node identifier and returns the type of that node.","Process Name":"getroute2","Link":"https:\/\/linux.die.net\/man\/2\/getroute2"}},{"Process":{"Description":null,"Process Name":"getrtype","Link":"https:\/\/linux.die.net\/man\/2\/getrtype"}},{"Process":{"Description":"getrusage() returns resource usage measures for who, which can be one of the following: RUSAGE_SELF Return resource usage statistics for the calling process, which is the sum of resources used by all threads in the process. RUSAGE_CHILDREN Return resource usage statistics for all children of the calling process that have terminated and been waited for. These statistics will include the resources used by grandchildren, and further removed descendants, if all of the intervening descendants waited on their terminated children. RUSAGE_THREAD (since Linux 2.6.26) Return resource usage statistics for the calling thread. The resource usages are returned in the structure pointed to by usage, which has the following form: struct rusage {\n    struct timeval ru_utime; \/* user CPU time used *\/\n    struct timeval ru_stime; \/* system CPU time used *\/\n    long   ru_maxrss;        \/* maximum resident set size *\/\n    long   ru_ixrss;         \/* integral shared memory size *\/\n    long   ru_idrss;         \/* integral unshared data size *\/\n    long   ru_isrss;         \/* integral unshared stack size *\/\n    long   ru_minflt;        \/* page reclaims (soft page faults) *\/\n    long   ru_majflt;        \/* page faults (hard page faults) *\/\n    long   ru_nswap;         \/* swaps *\/\n    long   ru_inblock;       \/* block input operations *\/\n    long   ru_oublock;       \/* block output operations *\/\n    long   ru_msgsnd;        \/* IPC messages sent *\/\n    long   ru_msgrcv;        \/* IPC messages received *\/\n    long   ru_nsignals;      \/* signals received *\/\n    long   ru_nvcsw;         \/* voluntary context switches *\/\n    long   ru_nivcsw;        \/* involuntary context switches *\/\n}; Not all fields are completed; unmaintained fields are set to zero by the kernel. (The unmaintained fields are provided for compatibility with other systems, and because they may one day be supported on Linux.) The fields are interpreted as follows: ru_utime This is the total amount of time spent executing in user mode, expressed in a timeval structure (seconds plus microseconds). ru_stime This is the total amount of time spent executing in kernel mode, expressed in a timeval structure (seconds plus microseconds). ru_maxrss (since Linux 2.6.32) This is the maximum resident set size used (in kilobytes). For RUSAGE_CHILDREN, this is the resident set size of the largest child, not the maximum resident set size of the process tree. ru_ixrss (unmaintained) This field is currently unused on Linux. ru_idrss (unmaintained) This field is currently unused on Linux. ru_isrss (unmaintained) This field is currently unused on Linux. ru_minflt The number of page faults serviced without any I\/O activity; here I\/O activity is avoided by \"reclaiming\" a page frame from the list of pages awaiting reallocation. ru_majflt The number of page faults serviced that required I\/O activity. ru_nswap (unmaintained) This field is currently unused on Linux. ru_inblock (since Linux 2.6.22) The number of times the file system had to perform input. ru_oublock (since Linux 2.6.22) The number of times the file system had to perform output. ru_msgsnd (unmaintained) This field is currently unused on Linux. ru_msgrcv (unmaintained) This field is currently unused on Linux. ru_nsignals (unmaintained) This field is currently unused on Linux. ru_nvcsw (since Linux 2.6) The number of times a context switch resulted due to a process voluntarily giving up the processor before its time slice was completed (usually to await availability of a resource). ru_nivcsw (since Linux 2.6) The number of times a context switch resulted due to a higher priority process becoming runnable or because the current process exceeded its time slice.","Process Name":"getrusage","Link":"https:\/\/linux.die.net\/man\/2\/getrusage"}},{"Process":{"Description":null,"Process Name":"getsid","Link":"https:\/\/linux.die.net\/man\/2\/getsid"}},{"Process":{"Description":"getsockname() returns the current address to which the socket sockfd is bound, in the buffer pointed to by addr. The addrlen argument should be initialized to indicate the amount of space (in bytes) pointed to by addr. On return it contains the actual size of the socket address. The returned address is truncated if the buffer provided is too small; in this case, addrlen will return a value greater than was supplied to the call.","Process Name":"getsockname","Link":"https:\/\/linux.die.net\/man\/2\/getsockname"}},{"Process":{"Description":null,"Process Name":"getsockopt","Link":"https:\/\/linux.die.net\/man\/2\/getsockopt"}},{"Process":{"Description":null,"Process Name":"gettid","Link":"https:\/\/linux.die.net\/man\/2\/gettid"}},{"Process":{"Description":"The functions gettimeofday() and settimeofday() can get and set the time as well as a timezone. The tv argument is a struct timeval (as specified in <sys\/time.h>): struct timeval {\n    time_t      tv_sec;     \/* seconds *\/\n    suseconds_t tv_usec;    \/* microseconds *\/\n}; and gives the number of seconds and microseconds since the Epoch (see time(2)). The tz argument is a struct timezone: struct timezone {\n    int tz_minuteswest;     \/* minutes west of Greenwich *\/\n    int tz_dsttime;         \/* type of DST correction *\/\n}; If either tv or tz is NULL, the corresponding structure is not set or returned. (However, compilation warnings will result if tv is NULL.) The use of the timezone structure is obsolete; the tz argument should normally be specified as NULL. (See NOTES below.) Under Linux there are some peculiar \"warp clock\" semantics associated with the settimeofday() system call if on the very first call (after booting) that has a non-NULL tz argument, the tv argument is NULL and the tz_minuteswest field is nonzero. (The tz_dsttime field should be zero for this case.) In such a case it is assumed that the CMOS clock is on local time, and that it has to be incremented by this amount to get UTC system time. No doubt it is a bad idea to use this feature.","Process Name":"gettimeofday","Link":"https:\/\/linux.die.net\/man\/2\/gettimeofday"}},{"Process":{"Description":"getuid() returns the real user ID of the calling process. geteuid() returns the effective user ID of the calling process.","Process Name":"getuid","Link":"https:\/\/linux.die.net\/man\/2\/getuid"}},{"Process":{"Description":null,"Process Name":"getuid32","Link":"https:\/\/linux.die.net\/man\/2\/getuid32"}},{"Process":{"Description":null,"Process Name":"getunwind","Link":"https:\/\/linux.die.net\/man\/2\/getunwind"}},{"Process":{"Description":null,"Process Name":"getxattr","Link":"https:\/\/linux.die.net\/man\/2\/getxattr"}},{"Process":{"Description":null,"Process Name":"gjones","Link":"https:\/\/linux.die.net\/man\/2\/gjones"}},{"Process":{"Description":null,"Process Name":"gnodes","Link":"https:\/\/linux.die.net\/man\/2\/gnodes"}},{"Process":{"Description":null,"Process Name":"gotbs","Link":"https:\/\/linux.die.net\/man\/2\/gotbs"}},{"Process":{"Description":"These system calls are not implemented in the Linux kernel.","Process Name":"gtty","Link":"https:\/\/linux.die.net\/man\/2\/gtty"}}]